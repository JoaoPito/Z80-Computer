Sjasm Z80 Assembler v0.42c - www.xl2s.tk             [2017.09.13 - 18:41:20]

CPM22.z80
Errors: 0

       1   00:DC00                      ;**************************************************************
       2   00:DC00                      ;*
       3   00:DC00                      ;*             C P / M   version   2 . 2
       4   00:DC00                      ;*
       5   00:DC00                      ;*   Reconstructed from memory image on February 27, 1981
       6   00:DC00                      ;*
       7   00:DC00                      ;*                by Clark A. Calkins
       8   00:DC00                      ;*
       9   00:DC00                      ;**************************************************************
      10   00:DC00                      ;
      11   00:DC00                      ;   Set memory limit here. This is the amount of contigeous
      12   00:DC00                      ; ram starting from 0000. CP/M will reside at the end of this space.
      13   00:DC00                      ;
      14   00:DC00  (00:003E)           MEM	EQU	62		;for a 62k system
      15   00:DC00                      ;
      16   00:DC00  (00:0003)           IOBYTE	EQU	3		;i/o definition byte.
      17   00:DC00  (00:0004)           TDRIVE	EQU	4		;current drive name and user number.
      18   00:DC00  (00:0005)           ENTRY	EQU	5		;entry point for the cp/m bdos.
      19   00:DC00  (00:005C)           TFCB	EQU	5CH		;default file control block.
      20   00:DC00  (00:0080)           TBUFF	EQU	80H		;i/o buffer and command line storage.
      21   00:DC00  (00:8000)           TBASE	EQU	8000H	;transiant program storage area.
      22   00:DC00                      ;
      23   00:DC00                      ;   Set control character equates.
      24   00:DC00                      ;
      25   00:DC00  (00:0003)           CNTRLC	EQU	3		;control-c
      26   00:DC00  (00:0005)           CNTRLE	EQU	05H		;control-e
      27   00:DC00  (00:0008)           BS	EQU	08H		;backspace
      28   00:DC00  (00:0009)           TAB	EQU	09H		;tab
      29   00:DC00  (00:000A)           LF	EQU	0AH		;line feed
      30   00:DC00  (00:000C)           FF	EQU	0CH		;form feed
      31   00:DC00  (00:000D)           CR	EQU	0DH		;carriage return
      32   00:DC00  (00:0010)           CNTRLP	EQU	10H		;control-p
      33   00:DC00  (00:0012)           CNTRLR	EQU	12H		;control-r
      34   00:DC00  (00:0013)           CNTRLS	EQU	13H		;control-s
      35   00:DC00  (00:0015)           CNTRLU	EQU	15H		;control-u
      36   00:DC00  (00:0018)           CNTRLX	EQU	18H		;control-x
      37   00:DC00  (00:001A)           CNTRLZ	EQU	1AH		;control-z (end-of-file mark)
      38   00:DC00  (00:007F)           DEL	EQU	7FH		;rubout
      39   00:DC00                      ;
      40   00:DC00                      ;   Set origin for CP/M
      41   00:DC00                      ;
      42   00:DC00                      	ORG	(MEM-7)*1024
      43   00:DC00                      ;
      44   00:DC00  C3 5C DF            CBASE:	JP	COMMAND		;execute command processor (ccp).
      45   00:DC03  C3 58 DF            	JP	CLEARBUF	;entry to empty input buffer before starting ccp.
      46   00:DC06                      
      47   00:DC06                      ;
      48   00:DC06                      ;   Standard cp/m ccp input buffer. Format is (max length),
      49   00:DC06                      ; (actual length), (char #1), (char #2), (char #3), etc.
      50   00:DC06                      ;
      51   00:DC06  7F                  INBUFF:	DEFB	127		;length of input buffer.
      52   00:DC07  00                  	DEFB	0		;current length of contents.
      53   00:DC08                      	DEFB	'Copyright'
      53   00:DC08  43 6F 70 79 72 69 67 68 74 
      54   00:DC11                      	DEFB	' 1979 (c) by Digital Research      '
      54   00:DC11  20 31 39 37 39 20 28 63 29 20 62 79 20 44 69 67 
      54   00:DC21  69 74 61 6C 20 52 65 73 65 61 72 63 68 20 20 20 
      54   00:DC31  20 20 20 
      55   00:DC34                      	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
      55   00:DC34  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      55   00:DC44  00 00 00 00 00 00 00 
      56   00:DC4B                      	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
      56   00:DC4B  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      56   00:DC5B  00 00 00 00 00 00 00 
      57   00:DC62                      	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
      57   00:DC62  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      57   00:DC72  00 00 00 00 00 00 00 
      58   00:DC79                      	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
      58   00:DC79  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
      59   00:DC88  08 DC               INPOINT:DEFW	INBUFF+2	;input line pointer
      60   00:DC8A  00 00               NAMEPNT:DEFW	0		;input line pointer used for error message. Points to
      61   00:DC8C                      ;			;start of name in error.
      62   00:DC8C                      ;
      63   00:DC8C                      ;   Routine to print (A) on the console. All registers used.
      64   00:DC8C                      ;
      65   00:DC8C  5F                  PRINT:	LD	E,A		;setup bdos call.
      66   00:DC8D  0E 02               	LD	C,2
      67   00:DC8F  C3 05 00            	JP	ENTRY
      68   00:DC92                      ;
      69   00:DC92                      ;   Routine to print (A) on the console and to save (BC).
      70   00:DC92                      ;
      71   00:DC92  C5                  PRINTB:	PUSH	BC
      72   00:DC93  CD 8C DC            	CALL	PRINT
      73   00:DC96  C1                  	POP	BC
      74   00:DC97  C9                  	RET	
      75   00:DC98                      ;
      76   00:DC98                      ;   Routine to send a carriage return, line feed combination
      77   00:DC98                      ; to the console.
      78   00:DC98                      ;
      79   00:DC98  3E 0D               CRLF:	LD	A,CR
      80   00:DC9A  CD 92 DC            	CALL	PRINTB
      81   00:DC9D  3E 0A               	LD	A,LF
      82   00:DC9F  C3 92 DC            	JP	PRINTB
      83   00:DCA2                      ;
      84   00:DCA2                      ;   Routine to send one space to the console and save (BC).
      85   00:DCA2                      ;
      86   00:DCA2  3E 20               SPACE:	LD	A,' '
      87   00:DCA4  C3 92 DC            	JP	PRINTB
      88   00:DCA7                      ;
      89   00:DCA7                      ;   Routine to print character string pointed to be (BC) on the
      90   00:DCA7                      ; console. It must terminate with a null byte.
      91   00:DCA7                      ;
      92   00:DCA7  C5                  PLINE:	PUSH	BC
      93   00:DCA8  CD 98 DC            	CALL	CRLF
      94   00:DCAB  E1                  	POP	HL
      95   00:DCAC  7E                  PLINE2:	LD	A,(HL)
      96   00:DCAD  B7                  	OR	A
      97   00:DCAE  C8                  	RET	Z
      98   00:DCAF  23                  	INC	HL
      99   00:DCB0  E5                  	PUSH	HL
     100   00:DCB1  CD 8C DC            	CALL	PRINT
     101   00:DCB4  E1                  	POP	HL
     102   00:DCB5  C3 AC DC            	JP	PLINE2
     103   00:DCB8                      ;
     104   00:DCB8                      ;   Routine to reset the disk system.
     105   00:DCB8                      ;
     106   00:DCB8  0E 0D               RESDSK:	LD	C,13
     107   00:DCBA  C3 05 00            	JP	ENTRY
     108   00:DCBD                      ;
     109   00:DCBD                      ;   Routine to select disk (A).
     110   00:DCBD                      ;
     111   00:DCBD  5F                  DSKSEL:	LD	E,A
     112   00:DCBE  0E 0E               	LD	C,14
     113   00:DCC0  C3 05 00            	JP	ENTRY
     114   00:DCC3                      ;
     115   00:DCC3                      ;   Routine to call bdos and save the return code. The zero
     116   00:DCC3                      ; flag is set on a return of 0ffh.
     117   00:DCC3                      ;
     118   00:DCC3  CD 05 00            ENTRY1:	CALL	ENTRY
     119   00:DCC6  32 EE E3            	LD	(RTNCODE),A	;save return code.
     120   00:DCC9  3C                  	INC	A		;set zero if 0ffh returned.
     121   00:DCCA  C9                  	RET	
     122   00:DCCB                      ;
     123   00:DCCB                      ;   Routine to open a file. (DE) must point to the FCB.
     124   00:DCCB                      ;
     125   00:DCCB  0E 0F               OPEN:	LD	C,15
     126   00:DCCD  C3 C3 DC            	JP	ENTRY1
     127   00:DCD0                      ;
     128   00:DCD0                      ;   Routine to open file at (FCB).
     129   00:DCD0                      ;
     130   00:DCD0  AF                  OPENFCB:XOR	A		;clear the record number byte at fcb+32
     131   00:DCD1  32 ED E3            	LD	(FCB+32),A
     132   00:DCD4  11 CD E3            	LD	DE,FCB
     133   00:DCD7  C3 CB DC            	JP	OPEN
     134   00:DCDA                      ;
     135   00:DCDA                      ;   Routine to close a file. (DE) points to FCB.
     136   00:DCDA                      ;
     137   00:DCDA  0E 10               CLOSE:	LD	C,16
     138   00:DCDC  C3 C3 DC            	JP	ENTRY1
     139   00:DCDF                      ;
     140   00:DCDF                      ;   Routine to search for the first file with ambigueous name
     141   00:DCDF                      ; (DE).
     142   00:DCDF                      ;
     143   00:DCDF  0E 11               SRCHFST:LD	C,17
     144   00:DCE1  C3 C3 DC            	JP	ENTRY1
     145   00:DCE4                      ;
     146   00:DCE4                      ;   Search for the next ambigeous file name.
     147   00:DCE4                      ;
     148   00:DCE4  0E 12               SRCHNXT:LD	C,18
     149   00:DCE6  C3 C3 DC            	JP	ENTRY1
     150   00:DCE9                      ;
     151   00:DCE9                      ;   Search for file at (FCB).
     152   00:DCE9                      ;
     153   00:DCE9  11 CD E3            SRCHFCB:LD	DE,FCB
     154   00:DCEC  C3 DF DC            	JP	SRCHFST
     155   00:DCEF                      ;
     156   00:DCEF                      ;   Routine to delete a file pointed to by (DE).
     157   00:DCEF                      ;
     158   00:DCEF  0E 13               DELETE:	LD	C,19
     159   00:DCF1  C3 05 00            	JP	ENTRY
     160   00:DCF4                      ;
     161   00:DCF4                      ;   Routine to call the bdos and set the zero flag if a zero
     162   00:DCF4                      ; status is returned.
     163   00:DCF4                      ;
     164   00:DCF4  CD 05 00            ENTRY2:	CALL	ENTRY
     165   00:DCF7  B7                  	OR	A		;set zero flag if appropriate.
     166   00:DCF8  C9                  	RET	
     167   00:DCF9                      ;
     168   00:DCF9                      ;   Routine to read the next record from a sequential file.
     169   00:DCF9                      ; (DE) points to the FCB.
     170   00:DCF9                      ;
     171   00:DCF9  0E 14               RDREC:	LD	C,20
     172   00:DCFB  C3 F4 DC            	JP	ENTRY2
     173   00:DCFE                      ;
     174   00:DCFE                      ;   Routine to read file at (FCB).
     175   00:DCFE                      ;
     176   00:DCFE  11 CD E3            READFCB:LD	DE,FCB
     177   00:DD01  C3 F9 DC            	JP	RDREC
     178   00:DD04                      ;
     179   00:DD04                      ;   Routine to write the next record of a sequential file.
     180   00:DD04                      ; (DE) points to the FCB.
     181   00:DD04                      ;
     182   00:DD04  0E 15               WRTREC:	LD	C,21
     183   00:DD06  C3 F4 DC            	JP	ENTRY2
     184   00:DD09                      ;
     185   00:DD09                      ;   Routine to create the file pointed to by (DE).
     186   00:DD09                      ;
     187   00:DD09  0E 16               CREATE:	LD	C,22
     188   00:DD0B  C3 C3 DC            	JP	ENTRY1
     189   00:DD0E                      ;
     190   00:DD0E                      ;   Routine to rename the file pointed to by (DE). Note that
     191   00:DD0E                      ; the new name starts at (DE+16).
     192   00:DD0E                      ;
     193   00:DD0E  0E 17               RENAM:	LD	C,23
     194   00:DD10  C3 05 00            	JP	ENTRY
     195   00:DD13                      ;
     196   00:DD13                      ;   Get the current user code.
     197   00:DD13                      ;
     198   00:DD13  1E FF               GETUSR:	LD	E,0FFH
     199   00:DD15                      ;
     200   00:DD15                      ;   Routne to get or set the current user code.
     201   00:DD15                      ; If (E) is FF then this is a GET, else it is a SET.
     202   00:DD15                      ;
     203   00:DD15  0E 20               GETSETUC: LD	C,32
     204   00:DD17  C3 05 00            	JP	ENTRY
     205   00:DD1A                      ;
     206   00:DD1A                      ;   Routine to set the current drive byte at (TDRIVE).
     207   00:DD1A                      ;
     208   00:DD1A  CD 13 DD            SETCDRV:CALL	GETUSR		;get user number
     209   00:DD1D  87                  	ADD	A,A		;and shift into the upper 4 bits.
     210   00:DD1E  87                  	ADD	A,A
     211   00:DD1F  87                  	ADD	A,A
     212   00:DD20  87                  	ADD	A,A
     213   00:DD21  21 EF E3            	LD	HL,CDRIVE	;now add in the current drive number.
     214   00:DD24  B6                  	OR	(HL)
     215   00:DD25  32 04 00            	LD	(TDRIVE),A	;and save.
     216   00:DD28  C9                  	RET	
     217   00:DD29                      ;
     218   00:DD29                      ;   Move currently active drive down to (TDRIVE).
     219   00:DD29                      ;
     220   00:DD29  3A EF E3            MOVECD:	LD	A,(CDRIVE)
     221   00:DD2C  32 04 00            	LD	(TDRIVE),A
     222   00:DD2F  C9                  	RET	
     223   00:DD30                      ;
     224   00:DD30                      ;   Routine to convert (A) into upper case ascii. Only letters
     225   00:DD30                      ; are affected.
     226   00:DD30                      ;
     227   00:DD30  FE 61               UPPER:	CP	'a'		;check for letters in the range of 'a' to 'z'.
     228   00:DD32  D8                  	RET	C
     229   00:DD33  FE 7B               	CP	'{'
     230   00:DD35  D0                  	RET	NC
     231   00:DD36  E6 5F               	AND	5FH		;convert it if found.
     232   00:DD38  C9                  	RET	
     233   00:DD39                      ;
     234   00:DD39                      ;   Routine to get a line of input. We must check to see if the
     235   00:DD39                      ; user is in (BATCH) mode. If so, then read the input from file
     236   00:DD39                      ; ($$$.SUB). At the end, reset to console input.
     237   00:DD39                      ;
     238   00:DD39  3A AB E3            GETINP:	LD	A,(BATCH)	;if =0, then use console input.
     239   00:DD3C  B7                  	OR	A
     240   00:DD3D  CA 96 DD            	JP	Z,GETINP1
     241   00:DD40                      ;
     242   00:DD40                      ;   Use the submit file ($$$.sub) which is prepared by a
     243   00:DD40                      ; SUBMIT run. It must be on drive (A) and it will be deleted
     244   00:DD40                      ; if and error occures (like eof).
     245   00:DD40                      ;
     246   00:DD40  3A EF E3            	LD	A,(CDRIVE)	;select drive 0 if need be.
     247   00:DD43  B7                  	OR	A
     248   00:DD44  3E 00               	LD	A,0		;always use drive A for submit.
     249   00:DD46  C4 BD DC            	CALL	NZ,DSKSEL	;select it if required.
     250   00:DD49  11 AC E3            	LD	DE,BATCHFCB
     251   00:DD4C  CD CB DC            	CALL	OPEN		;look for it.
     252   00:DD4F  CA 96 DD            	JP	Z,GETINP1	;if not there, use normal input.
     253   00:DD52  3A BB E3            	LD	A,(BATCHFCB+15)	;get last record number+1.
     254   00:DD55  3D                  	DEC	A
     255   00:DD56  32 CC E3            	LD	(BATCHFCB+32),A
     256   00:DD59  11 AC E3            	LD	DE,BATCHFCB
     257   00:DD5C  CD F9 DC            	CALL	RDREC		;read last record.
     258   00:DD5F  C2 96 DD            	JP	NZ,GETINP1	;quit on end of file.
     259   00:DD62                      ;
     260   00:DD62                      ;   Move this record into input buffer.
     261   00:DD62                      ;
     262   00:DD62  11 07 DC            	LD	DE,INBUFF+1
     263   00:DD65  21 80 00            	LD	HL,TBUFF	;data was read into buffer here.
     264   00:DD68  06 80               	LD	B,128		;all 128 characters may be used.
     265   00:DD6A  CD 42 E0            	CALL	HL2DE		;(HL) to (DE), (B) bytes.
     266   00:DD6D  21 BA E3            	LD	HL,BATCHFCB+14
     267   00:DD70  36 00               	LD	(HL),0		;zero out the 's2' byte.
     268   00:DD72  23                  	INC	HL		;and decrement the record count.
     269   00:DD73  35                  	DEC	(HL)
     270   00:DD74  11 AC E3            	LD	DE,BATCHFCB	;close the batch file now.
     271   00:DD77  CD DA DC            	CALL	CLOSE
     272   00:DD7A  CA 96 DD            	JP	Z,GETINP1	;quit on an error.
     273   00:DD7D  3A EF E3            	LD	A,(CDRIVE)	;re-select previous drive if need be.
     274   00:DD80  B7                  	OR	A
     275   00:DD81  C4 BD DC            	CALL	NZ,DSKSEL	;don't do needless selects.
     276   00:DD84                      ;
     277   00:DD84                      ;   Print line just read on console.
     278   00:DD84                      ;
     279   00:DD84  21 08 DC            	LD	HL,INBUFF+2
     280   00:DD87  CD AC DC            	CALL	PLINE2
     281   00:DD8A  CD C2 DD            	CALL	CHKCON		;check console, quit on a key.
     282   00:DD8D  CA A7 DD            	JP	Z,GETINP2	;jump if no key is pressed.
     283   00:DD90                      ;
     284   00:DD90                      ;   Terminate the submit job on any keyboard input. Delete this
     285   00:DD90                      ; file such that it is not re-started and jump to normal keyboard
     286   00:DD90                      ; input section.
     287   00:DD90                      ;
     288   00:DD90  CD DD DD            	CALL	DELBATCH	;delete the batch file.
     289   00:DD93  C3 82 DF            	JP	CMMND1		;and restart command input.
     290   00:DD96                      ;
     291   00:DD96                      ;   Get here for normal keyboard input. Delete the submit file
     292   00:DD96                      ; incase there was one.
     293   00:DD96                      ;
     294   00:DD96  CD DD DD            GETINP1:CALL	DELBATCH	;delete file ($$$.sub).
     295   00:DD99  CD 1A DD            	CALL	SETCDRV		;reset active disk.
     296   00:DD9C  0E 0A               	LD	C,10		;get line from console device.
     297   00:DD9E  11 06 DC            	LD	DE,INBUFF
     298   00:DDA1  CD 05 00            	CALL	ENTRY
     299   00:DDA4  CD 29 DD            	CALL	MOVECD		;reset current drive (again).
     300   00:DDA7                      ;
     301   00:DDA7                      ;   Convert input line to upper case.
     302   00:DDA7                      ;
     303   00:DDA7  21 07 DC            GETINP2:LD	HL,INBUFF+1
     304   00:DDAA  46                  	LD	B,(HL)		;(B)=character counter.
     305   00:DDAB  23                  GETINP3:INC	HL
     306   00:DDAC  78                  	LD	A,B		;end of the line?
     307   00:DDAD  B7                  	OR	A
     308   00:DDAE  CA BA DD            	JP	Z,GETINP4
     309   00:DDB1  7E                  	LD	A,(HL)		;convert to upper case.
     310   00:DDB2  CD 30 DD            	CALL	UPPER
     311   00:DDB5  77                  	LD	(HL),A
     312   00:DDB6  05                  	DEC	B		;adjust character count.
     313   00:DDB7  C3 AB DD            	JP	GETINP3
     314   00:DDBA  77                  GETINP4:LD	(HL),A		;add trailing null.
     315   00:DDBB  21 08 DC            	LD	HL,INBUFF+2
     316   00:DDBE  22 88 DC            	LD	(INPOINT),HL	;reset input line pointer.
     317   00:DDC1  C9                  	RET	
     318   00:DDC2                      ;
     319   00:DDC2                      ;   Routine to check the console for a key pressed. The zero
     320   00:DDC2                      ; flag is set is none, else the character is returned in (A).
     321   00:DDC2                      ;
     322   00:DDC2  0E 0B               CHKCON:	LD	C,11		;check console.
     323   00:DDC4  CD 05 00            	CALL	ENTRY
     324   00:DDC7  B7                  	OR	A
     325   00:DDC8  C8                  	RET	Z		;return if nothing.
     326   00:DDC9  0E 01               	LD	C,1		;else get character.
     327   00:DDCB  CD 05 00            	CALL	ENTRY
     328   00:DDCE  B7                  	OR	A		;clear zero flag and return.
     329   00:DDCF  C9                  	RET	
     330   00:DDD0                      ;
     331   00:DDD0                      ;   Routine to get the currently active drive number.
     332   00:DDD0                      ;
     333   00:DDD0  0E 19               GETDSK:	LD	C,25
     334   00:DDD2  C3 05 00            	JP	ENTRY
     335   00:DDD5                      ;
     336   00:DDD5                      ;   Set the stabdard dma address.
     337   00:DDD5                      ;
     338   00:DDD5  11 80 00            STDDMA:	LD	DE,TBUFF
     339   00:DDD8                      ;
     340   00:DDD8                      ;   Routine to set the dma address to (DE).
     341   00:DDD8                      ;
     342   00:DDD8  0E 1A               DMASET:	LD	C,26
     343   00:DDDA  C3 05 00            	JP	ENTRY
     344   00:DDDD                      ;
     345   00:DDDD                      ;  Delete the batch file created by SUBMIT.
     346   00:DDDD                      ;
     347   00:DDDD  21 AB E3            DELBATCH: LD	HL,BATCH	;is batch active?
     348   00:DDE0  7E                  	LD	A,(HL)
     349   00:DDE1  B7                  	OR	A
     350   00:DDE2  C8                  	RET	Z
     351   00:DDE3  36 00               	LD	(HL),0		;yes, de-activate it.
     352   00:DDE5  AF                  	XOR	A
     353   00:DDE6  CD BD DC            	CALL	DSKSEL		;select drive 0 for sure.
     354   00:DDE9  11 AC E3            	LD	DE,BATCHFCB	;and delete this file.
     355   00:DDEC  CD EF DC            	CALL	DELETE
     356   00:DDEF  3A EF E3            	LD	A,(CDRIVE)	;reset current drive.
     357   00:DDF2  C3 BD DC            	JP	DSKSEL
     358   00:DDF5                      ;
     359   00:DDF5                      ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
     360   00:DDF5                      ; the same or we halt....
     361   00:DDF5                      ;
     362   00:DDF5  11 28 DF            VERIFY:	LD	DE,PATTRN1	;these are the serial number bytes.
     363   00:DDF8  21 00 E4            	LD	HL,PATTRN2	;ditto, but how could they be different?
     364   00:DDFB  06 06               	LD	B,6		;6 bytes each.
     365   00:DDFD  1A                  VERIFY1:LD	A,(DE)
     366   00:DDFE  BE                  	CP	(HL)
     367   00:DDFF  C2 CF DF            	JP	NZ,HALT		;jump to halt routine.
     368   00:DE02  13                  	INC	DE
     369   00:DE03  23                  	INC	HL
     370   00:DE04  05                  	DEC	B
     371   00:DE05  C2 FD DD            	JP	NZ,VERIFY1
     372   00:DE08  C9                  	RET	
     373   00:DE09                      ;
     374   00:DE09                      ;   Print back file name with a '?' to indicate a syntax error.
     375   00:DE09                      ;
     376   00:DE09  CD 98 DC            SYNERR:	CALL	CRLF		;end current line.
     377   00:DE0C  2A 8A DC            	LD	HL,(NAMEPNT)	;this points to name in error.
     378   00:DE0F  7E                  SYNERR1:LD	A,(HL)		;print it until a space or null is found.
     379   00:DE10  FE 20               	CP	' '
     380   00:DE12  CA 22 DE            	JP	Z,SYNERR2
     381   00:DE15  B7                  	OR	A
     382   00:DE16  CA 22 DE            	JP	Z,SYNERR2
     383   00:DE19  E5                  	PUSH	HL
     384   00:DE1A  CD 8C DC            	CALL	PRINT
     385   00:DE1D  E1                  	POP	HL
     386   00:DE1E  23                  	INC	HL
     387   00:DE1F  C3 0F DE            	JP	SYNERR1
     388   00:DE22  3E 3F               SYNERR2:LD	A,'?'		;add trailing '?'.
     389   00:DE24  CD 8C DC            	CALL	PRINT
     390   00:DE27  CD 98 DC            	CALL	CRLF
     391   00:DE2A  CD DD DD            	CALL	DELBATCH	;delete any batch file.
     392   00:DE2D  C3 82 DF            	JP	CMMND1		;and restart from console input.
     393   00:DE30                      ;
     394   00:DE30                      ;   Check character at (DE) for legal command input. Note that the
     395   00:DE30                      ; zero flag is set if the character is a delimiter.
     396   00:DE30                      ;
     397   00:DE30  1A                  CHECK:	LD	A,(DE)
     398   00:DE31  B7                  	OR	A
     399   00:DE32  C8                  	RET	Z
     400   00:DE33  FE 20               	CP	' '		;control characters are not legal here.
     401   00:DE35  DA 09 DE            	JP	C,SYNERR
     402   00:DE38  C8                  	RET	Z		;check for valid delimiter.
     403   00:DE39  FE 3D               	CP	'='
     404   00:DE3B  C8                  	RET	Z
     405   00:DE3C  FE 5F               	CP	'_'
     406   00:DE3E  C8                  	RET	Z
     407   00:DE3F  FE 2E               	CP	'.'
     408   00:DE41  C8                  	RET	Z
     409   00:DE42  FE 3A               	CP	':'
     410   00:DE44  C8                  	RET	Z
     411   00:DE45  FE 3B               	CP	';'
     412   00:DE47  C8                  	RET	Z
     413   00:DE48  FE 3C               	CP	'<'
     414   00:DE4A  C8                  	RET	Z
     415   00:DE4B  FE 3E               	CP	'>'
     416   00:DE4D  C8                  	RET	Z
     417   00:DE4E  C9                  	RET	
     418   00:DE4F                      ;
     419   00:DE4F                      ;   Get the next non-blank character from (DE).
     420   00:DE4F                      ;
     421   00:DE4F  1A                  NONBLANK: LD	A,(DE)
     422   00:DE50  B7                  	OR	A		;string ends with a null.
     423   00:DE51  C8                  	RET	Z
     424   00:DE52  FE 20               	CP	' '
     425   00:DE54  C0                  	RET	NZ
     426   00:DE55  13                  	INC	DE
     427   00:DE56  C3 4F DE            	JP	NONBLANK
     428   00:DE59                      ;
     429   00:DE59                      ;   Add (HL)=(HL)+(A)
     430   00:DE59                      ;
     431   00:DE59  85                  ADDHL:	ADD	A,L
     432   00:DE5A  6F                  	LD	L,A
     433   00:DE5B  D0                  	RET	NC		;take care of any carry.
     434   00:DE5C  24                  	INC	H
     435   00:DE5D  C9                  	RET	
     436   00:DE5E                      ;
     437   00:DE5E                      ;   Convert the first name in (FCB).
     438   00:DE5E                      ;
     439   00:DE5E  3E 00               CONVFST:LD	A,0
     440   00:DE60                      ;
     441   00:DE60                      ;   Format a file name (convert * to '?', etc.). On return,
     442   00:DE60                      ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
     443   00:DE60                      ; the position within the fcb for the name (either 0 or 16).
     444   00:DE60                      ;
     445   00:DE60  21 CD E3            CONVERT:LD	HL,FCB
     446   00:DE63  CD 59 DE            	CALL	ADDHL
     447   00:DE66  E5                  	PUSH	HL
     448   00:DE67  E5                  	PUSH	HL
     449   00:DE68  AF                  	XOR	A
     450   00:DE69  32 F0 E3            	LD	(CHGDRV),A	;initialize drive change flag.
     451   00:DE6C  2A 88 DC            	LD	HL,(INPOINT)	;set (HL) as pointer into input line.
     452   00:DE6F  EB                  	EX	DE,HL
     453   00:DE70  CD 4F DE            	CALL	NONBLANK	;get next non-blank character.
     454   00:DE73  EB                  	EX	DE,HL
     455   00:DE74  22 8A DC            	LD	(NAMEPNT),HL	;save pointer here for any error message.
     456   00:DE77  EB                  	EX	DE,HL
     457   00:DE78  E1                  	POP	HL
     458   00:DE79  1A                  	LD	A,(DE)		;get first character.
     459   00:DE7A  B7                  	OR	A
     460   00:DE7B  CA 89 DE            	JP	Z,CONVRT1
     461   00:DE7E  DE 40               	SBC	A,'A'-1		;might be a drive name, convert to binary.
     462   00:DE80  47                  	LD	B,A		;and save.
     463   00:DE81  13                  	INC	DE		;check next character for a ':'.
     464   00:DE82  1A                  	LD	A,(DE)
     465   00:DE83  FE 3A               	CP	':'
     466   00:DE85  CA 90 DE            	JP	Z,CONVRT2
     467   00:DE88  1B                  	DEC	DE		;nope, move pointer back to the start of the line.
     468   00:DE89  3A EF E3            CONVRT1:LD	A,(CDRIVE)
     469   00:DE8C  77                  	LD	(HL),A
     470   00:DE8D  C3 96 DE            	JP	CONVRT3
     471   00:DE90  78                  CONVRT2:LD	A,B
     472   00:DE91  32 F0 E3            	LD	(CHGDRV),A	;set change in drives flag.
     473   00:DE94  70                  	LD	(HL),B
     474   00:DE95  13                  	INC	DE
     475   00:DE96                      ;
     476   00:DE96                      ;   Convert the basic file name.
     477   00:DE96                      ;
     478   00:DE96  06 08               CONVRT3:LD	B,08H
     479   00:DE98  CD 30 DE            CONVRT4:CALL	CHECK
     480   00:DE9B  CA B9 DE            	JP	Z,CONVRT8
     481   00:DE9E  23                  	INC	HL
     482   00:DE9F  FE 2A               	CP	'*'		;note that an '*' will fill the remaining
     483   00:DEA1  C2 A9 DE            	JP	NZ,CONVRT5	;field with '?'.
     484   00:DEA4  36 3F               	LD	(HL),'?'
     485   00:DEA6  C3 AB DE            	JP	CONVRT6
     486   00:DEA9  77                  CONVRT5:LD	(HL),A
     487   00:DEAA  13                  	INC	DE
     488   00:DEAB  05                  CONVRT6:DEC	B
     489   00:DEAC  C2 98 DE            	JP	NZ,CONVRT4
     490   00:DEAF  CD 30 DE            CONVRT7:CALL	CHECK		;get next delimiter.
     491   00:DEB2  CA C0 DE            	JP	Z,GETEXT
     492   00:DEB5  13                  	INC	DE
     493   00:DEB6  C3 AF DE            	JP	CONVRT7
     494   00:DEB9  23                  CONVRT8:INC	HL		;blank fill the file name.
     495   00:DEBA  36 20               	LD	(HL),' '
     496   00:DEBC  05                  	DEC	B
     497   00:DEBD  C2 B9 DE            	JP	NZ,CONVRT8
     498   00:DEC0                      ;
     499   00:DEC0                      ;   Get the extension and convert it.
     500   00:DEC0                      ;
     501   00:DEC0  06 03               GETEXT:	LD	B,03H
     502   00:DEC2  FE 2E               	CP	'.'
     503   00:DEC4  C2 E9 DE            	JP	NZ,GETEXT5
     504   00:DEC7  13                  	INC	DE
     505   00:DEC8  CD 30 DE            GETEXT1:CALL	CHECK
     506   00:DECB  CA E9 DE            	JP	Z,GETEXT5
     507   00:DECE  23                  	INC	HL
     508   00:DECF  FE 2A               	CP	'*'
     509   00:DED1  C2 D9 DE            	JP	NZ,GETEXT2
     510   00:DED4  36 3F               	LD	(HL),'?'
     511   00:DED6  C3 DB DE            	JP	GETEXT3
     512   00:DED9  77                  GETEXT2:LD	(HL),A
     513   00:DEDA  13                  	INC	DE
     514   00:DEDB  05                  GETEXT3:DEC	B
     515   00:DEDC  C2 C8 DE            	JP	NZ,GETEXT1
     516   00:DEDF  CD 30 DE            GETEXT4:CALL	CHECK
     517   00:DEE2  CA F0 DE            	JP	Z,GETEXT6
     518   00:DEE5  13                  	INC	DE
     519   00:DEE6  C3 DF DE            	JP	GETEXT4
     520   00:DEE9  23                  GETEXT5:INC	HL
     521   00:DEEA  36 20               	LD	(HL),' '
     522   00:DEEC  05                  	DEC	B
     523   00:DEED  C2 E9 DE            	JP	NZ,GETEXT5
     524   00:DEF0  06 03               GETEXT6:LD	B,3
     525   00:DEF2  23                  GETEXT7:INC	HL
     526   00:DEF3  36 00               	LD	(HL),0
     527   00:DEF5  05                  	DEC	B
     528   00:DEF6  C2 F2 DE            	JP	NZ,GETEXT7
     529   00:DEF9  EB                  	EX	DE,HL
     530   00:DEFA  22 88 DC            	LD	(INPOINT),HL	;save input line pointer.
     531   00:DEFD  E1                  	POP	HL
     532   00:DEFE                      ;
     533   00:DEFE                      ;   Check to see if this is an ambigeous file name specification.
     534   00:DEFE                      ; Set the (A) register to non zero if it is.
     535   00:DEFE                      ;
     536   00:DEFE  01 0B 00            	LD	BC,11		;set name length.
     537   00:DF01  23                  GETEXT8:INC	HL
     538   00:DF02  7E                  	LD	A,(HL)
     539   00:DF03  FE 3F               	CP	'?'		;any question marks?
     540   00:DF05  C2 09 DF            	JP	NZ,GETEXT9
     541   00:DF08  04                  	INC	B		;count them.
     542   00:DF09  0D                  GETEXT9:DEC	C
     543   00:DF0A  C2 01 DF            	JP	NZ,GETEXT8
     544   00:DF0D  78                  	LD	A,B
     545   00:DF0E  B7                  	OR	A
     546   00:DF0F  C9                  	RET	
     547   00:DF10                      ;
     548   00:DF10                      ;   CP/M command table. Note commands can be either 3 or 4 characters long.
     549   00:DF10                      ;
     550   00:DF10  (00:0006)           NUMCMDS EQU	6		;number of commands
     551   00:DF10  44 49 52 20         CMDTBL:	DEFB	'DIR '
     552   00:DF14  45 52 41 20         	DEFB	'ERA '
     553   00:DF18  54 59 50 45         	DEFB	'TYPE'
     554   00:DF1C  53 41 56 45         	DEFB	'SAVE'
     555   00:DF20  52 45 4E 20         	DEFB	'REN '
     556   00:DF24  55 53 45 52         	DEFB	'USER'
     557   00:DF28                      ;
     558   00:DF28                      ;   The following six bytes must agree with those at (PATTRN2)
     559   00:DF28                      ; or cp/m will HALT. Why?
     560   00:DF28                      ;
     561   00:DF28  00 16 00 00 00 00   PATTRN1:DEFB	0,22,0,0,0,0	;(* serial number bytes *).
     562   00:DF2E                      ;
     563   00:DF2E                      ;   Search the command table for a match with what has just
     564   00:DF2E                      ; been entered. If a match is found, then we jump to the
     565   00:DF2E                      ; proper section. Else jump to (UNKNOWN).
     566   00:DF2E                      ; On return, the (C) register is set to the command number
     567   00:DF2E                      ; that matched (or NUMCMDS+1 if no match).
     568   00:DF2E                      ;
     569   00:DF2E  21 10 DF            SEARCH:	LD	HL,CMDTBL
     570   00:DF31  0E 00               	LD	C,0
     571   00:DF33  79                  SEARCH1:LD	A,C
     572   00:DF34  FE 06               	CP	NUMCMDS		;this commands exists.
     573   00:DF36  D0                  	RET	NC
     574   00:DF37  11 CE E3            	LD	DE,FCB+1	;check this one.
     575   00:DF3A  06 04               	LD	B,4		;max command length.
     576   00:DF3C  1A                  SEARCH2:LD	A,(DE)
     577   00:DF3D  BE                  	CP	(HL)
     578   00:DF3E  C2 4F DF            	JP	NZ,SEARCH3	;not a match.
     579   00:DF41  13                  	INC	DE
     580   00:DF42  23                  	INC	HL
     581   00:DF43  05                  	DEC	B
     582   00:DF44  C2 3C DF            	JP	NZ,SEARCH2
     583   00:DF47  1A                  	LD	A,(DE)		;allow a 3 character command to match.
     584   00:DF48  FE 20               	CP	' '
     585   00:DF4A  C2 54 DF            	JP	NZ,SEARCH4
     586   00:DF4D  79                  	LD	A,C		;set return register for this command.
     587   00:DF4E  C9                  	RET	
     588   00:DF4F  23                  SEARCH3:INC	HL
     589   00:DF50  05                  	DEC	B
     590   00:DF51  C2 4F DF            	JP	NZ,SEARCH3
     591   00:DF54  0C                  SEARCH4:INC	C
     592   00:DF55  C3 33 DF            	JP	SEARCH1
     593   00:DF58                      ;
     594   00:DF58                      ;   Set the input buffer to empty and then start the command
     595   00:DF58                      ; processor (ccp).
     596   00:DF58                      ;
     597   00:DF58  AF                  CLEARBUF: XOR	A
     598   00:DF59  32 07 DC            	LD	(INBUFF+1),A	;second byte is actual length.
     599   00:DF5C                      ;
     600   00:DF5C                      ;**************************************************************
     601   00:DF5C                      ;*
     602   00:DF5C                      ;*
     603   00:DF5C                      ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
     604   00:DF5C                      ;*
     605   00:DF5C                      ;**************************************************************
     606   00:DF5C                      ;*
     607   00:DF5C  31 FF FF            COMMAND:LD	SP,CCPSTACK	;setup stack area.
     608   00:DF5F  C5                  	PUSH	BC		;note that (C) should be equal to:
     609   00:DF60  79                  	LD	A,C		;(uuuudddd) where 'uuuu' is the user number
     610   00:DF61  1F                  	RRA			;and 'dddd' is the drive number.
     611   00:DF62  1F                  	RRA	
     612   00:DF63  1F                  	RRA	
     613   00:DF64  1F                  	RRA	
     614   00:DF65  E6 0F               	AND	0FH		;isolate the user number.
     615   00:DF67  5F                  	LD	E,A
     616   00:DF68  CD 15 DD            	CALL	GETSETUC	;and set it.
     617   00:DF6B  CD B8 DC            	CALL	RESDSK		;reset the disk system.
     618   00:DF6E  32 AB E3            	LD	(BATCH),A	;clear batch mode flag.
     619   00:DF71  C1                  	POP	BC
     620   00:DF72  79                  	LD	A,C
     621   00:DF73  E6 0F               	AND	0FH		;isolate the drive number.
     622   00:DF75  32 EF E3            	LD	(CDRIVE),A	;and save.
     623   00:DF78  CD BD DC            	CALL	DSKSEL		;...and select.
     624   00:DF7B  3A 07 DC            	LD	A,(INBUFF+1)
     625   00:DF7E  B7                  	OR	A		;anything in input buffer already?
     626   00:DF7F  C2 98 DF            	JP	NZ,CMMND2	;yes, we just process it.
     627   00:DF82                      ;
     628   00:DF82                      ;   Entry point to get a command line from the console.
     629   00:DF82                      ;
     630   00:DF82  31 FF FF            CMMND1:	LD	SP,CCPSTACK	;set stack straight.
     631   00:DF85  CD 98 DC            	CALL	CRLF		;start a new line on the screen.
     632   00:DF88  CD D0 DD            	CALL	GETDSK		;get current drive.
     633   00:DF8B  C6 61               	ADD	A,'a'
     634   00:DF8D  CD 8C DC            	CALL	PRINT		;print current drive.
     635   00:DF90  3E 3E               	LD	A,'>'
     636   00:DF92  CD 8C DC            	CALL	PRINT		;and add prompt.
     637   00:DF95  CD 39 DD            	CALL	GETINP		;get line from user.
     638   00:DF98                      ;
     639   00:DF98                      ;   Process command line here.
     640   00:DF98                      ;
     641   00:DF98  11 80 00            CMMND2:	LD	DE,TBUFF
     642   00:DF9B  CD D8 DD            	CALL	DMASET		;set standard dma address.
     643   00:DF9E  CD D0 DD            	CALL	GETDSK
     644   00:DFA1  32 EF E3            	LD	(CDRIVE),A	;set current drive.
     645   00:DFA4  CD 5E DE            	CALL	CONVFST		;convert name typed in.
     646   00:DFA7  C4 09 DE            	CALL	NZ,SYNERR	;wild cards are not allowed.
     647   00:DFAA  3A F0 E3            	LD	A,(CHGDRV)	;if a change in drives was indicated,
     648   00:DFAD  B7                  	OR	A		;then treat this as an unknown command
     649   00:DFAE  C2 A5 E2            	JP	NZ,UNKNOWN	;which gets executed.
     650   00:DFB1  CD 2E DF            	CALL	SEARCH		;else search command table for a match.
     651   00:DFB4                      ;
     652   00:DFB4                      ;   Note that an unknown command returns
     653   00:DFB4                      ; with (A) pointing to the last address
     654   00:DFB4                      ; in our table which is (UNKNOWN).
     655   00:DFB4                      ;
     656   00:DFB4  21 C1 DF            	LD	HL,CMDADR	;now, look thru our address table for command (A).
     657   00:DFB7  5F                  	LD	E,A		;set (DE) to command number.
     658   00:DFB8  16 00               	LD	D,0
     659   00:DFBA  19                  	ADD	HL,DE
     660   00:DFBB  19                  	ADD	HL,DE		;(HL)=(CMDADR)+2*(command number).
     661   00:DFBC  7E                  	LD	A,(HL)		;now pick out this address.
     662   00:DFBD  23                  	INC	HL
     663   00:DFBE  66                  	LD	H,(HL)
     664   00:DFBF  6F                  	LD	L,A
     665   00:DFC0  E9                  	JP	(HL)		;now execute it.
     666   00:DFC1                      ;
     667   00:DFC1                      ;   CP/M command address table.
     668   00:DFC1                      ;
     669   00:DFC1                      CMDADR:	DEFW	DIRECT,ERASE,TYPE,SAVE
     669   00:DFC1  77 E0 1F E1 5D E1 AD E1 
     670   00:DFC9  10 E2 8E E2 A5 E2   	DEFW	RENAME,USER,UNKNOWN
     671   00:DFCF                      ;
     672   00:DFCF                      ;   Halt the system. Reason for this is unknown at present.
     673   00:DFCF                      ;
     674   00:DFCF  21 F3 76            HALT:	LD	HL,76F3H	;'DI HLT' instructions.
     675   00:DFD2  22 00 DC            	LD	(CBASE),HL
     676   00:DFD5  21 00 DC            	LD	HL,CBASE
     677   00:DFD8  E9                  	JP	(HL)
     678   00:DFD9                      ;
     679   00:DFD9                      ;   Read error while TYPEing a file.
     680   00:DFD9                      ;
     681   00:DFD9  01 DF DF            RDERROR:LD	BC,RDERR
     682   00:DFDC  C3 A7 DC            	JP	PLINE
     683   00:DFDF                      RDERR:	DEFB	'Read error',0
     683   00:DFDF  52 65 61 64 20 65 72 72 6F 72 00 
     684   00:DFEA                      ;
     685   00:DFEA                      ;   Required file was not located.
     686   00:DFEA                      ;
     687   00:DFEA  01 F0 DF            NONE:	LD	BC,NOFILE
     688   00:DFED  C3 A7 DC            	JP	PLINE
     689   00:DFF0                      NOFILE:	DEFB	'No file',0
     689   00:DFF0  4E 6F 20 66 69 6C 65 00 
     690   00:DFF8                      ;
     691   00:DFF8                      ;   Decode a command of the form 'A>filename number{ filename}.
     692   00:DFF8                      ; Note that a drive specifier is not allowed on the first file
     693   00:DFF8                      ; name. On return, the number is in register (A). Any error
     694   00:DFF8                      ; causes 'filename?' to be printed and the command is aborted.
     695   00:DFF8                      ;
     696   00:DFF8  CD 5E DE            DECODE:	CALL	CONVFST		;convert filename.
     697   00:DFFB  3A F0 E3            	LD	A,(CHGDRV)	;do not allow a drive to be specified.
     698   00:DFFE  B7                  	OR	A
     699   00:DFFF  C2 09 DE            	JP	NZ,SYNERR
     700   00:E002  21 CE E3            	LD	HL,FCB+1	;convert number now.
     701   00:E005  01 0B 00            	LD	BC,11		;(B)=sum register, (C)=max digit count.
     702   00:E008  7E                  DECODE1:LD	A,(HL)
     703   00:E009  FE 20               	CP	' '		;a space terminates the numeral.
     704   00:E00B  CA 33 E0            	JP	Z,DECODE3
     705   00:E00E  23                  	INC	HL
     706   00:E00F  D6 30               	SUB	'0'		;make binary from ascii.
     707   00:E011  FE 0A               	CP	10		;legal digit?
     708   00:E013  D2 09 DE            	JP	NC,SYNERR
     709   00:E016  57                  	LD	D,A		;yes, save it in (D).
     710   00:E017  78                  	LD	A,B		;compute (B)=(B)*10 and check for overflow.
     711   00:E018  E6 E0               	AND	0E0H
     712   00:E01A  C2 09 DE            	JP	NZ,SYNERR
     713   00:E01D  78                  	LD	A,B
     714   00:E01E  07                  	RLCA	
     715   00:E01F  07                  	RLCA	
     716   00:E020  07                  	RLCA			;(A)=(B)*8
     717   00:E021  80                  	ADD	A,B		;.......*9
     718   00:E022  DA 09 DE            	JP	C,SYNERR
     719   00:E025  80                  	ADD	A,B		;.......*10
     720   00:E026  DA 09 DE            	JP	C,SYNERR
     721   00:E029  82                  	ADD	A,D		;add in new digit now.
     722   00:E02A  DA 09 DE            DECODE2:JP	C,SYNERR
     723   00:E02D  47                  	LD	B,A		;and save result.
     724   00:E02E  0D                  	DEC	C		;only look at 11 digits.
     725   00:E02F  C2 08 E0            	JP	NZ,DECODE1
     726   00:E032  C9                  	RET	
     727   00:E033  7E                  DECODE3:LD	A,(HL)		;spaces must follow (why?).
     728   00:E034  FE 20               	CP	' '
     729   00:E036  C2 09 DE            	JP	NZ,SYNERR
     730   00:E039  23                  	INC	HL
     731   00:E03A  0D                  DECODE4:DEC	C
     732   00:E03B  C2 33 E0            	JP	NZ,DECODE3
     733   00:E03E  78                  	LD	A,B		;set (A)=the numeric value entered.
     734   00:E03F  C9                  	RET	
     735   00:E040                      ;
     736   00:E040                      ;   Move 3 bytes from (HL) to (DE). Note that there is only
     737   00:E040                      ; one reference to this at (A2D5h).
     738   00:E040                      ;
     739   00:E040  06 03               MOVE3:	LD	B,3
     740   00:E042                      ;
     741   00:E042                      ;   Move (B) bytes from (HL) to (DE).
     742   00:E042                      ;
     743   00:E042  7E                  HL2DE:	LD	A,(HL)
     744   00:E043  12                  	LD	(DE),A
     745   00:E044  23                  	INC	HL
     746   00:E045  13                  	INC	DE
     747   00:E046  05                  	DEC	B
     748   00:E047  C2 42 E0            	JP	NZ,HL2DE
     749   00:E04A  C9                  	RET	
     750   00:E04B                      ;
     751   00:E04B                      ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
     752   00:E04B                      ;
     753   00:E04B  21 80 00            EXTRACT:LD	HL,TBUFF
     754   00:E04E  81                  	ADD	A,C
     755   00:E04F  CD 59 DE            	CALL	ADDHL
     756   00:E052  7E                  	LD	A,(HL)
     757   00:E053  C9                  	RET	
     758   00:E054                      ;
     759   00:E054                      ;  Check drive specified. If it means a change, then the new
     760   00:E054                      ; drive will be selected. In any case, the drive byte of the
     761   00:E054                      ; fcb will be set to null (means use current drive).
     762   00:E054                      ;
     763   00:E054  AF                  DSELECT:XOR	A		;null out first byte of fcb.
     764   00:E055  32 CD E3            	LD	(FCB),A
     765   00:E058  3A F0 E3            	LD	A,(CHGDRV)	;a drive change indicated?
     766   00:E05B  B7                  	OR	A
     767   00:E05C  C8                  	RET	Z
     768   00:E05D  3D                  	DEC	A		;yes, is it the same as the current drive?
     769   00:E05E  21 EF E3            	LD	HL,CDRIVE
     770   00:E061  BE                  	CP	(HL)
     771   00:E062  C8                  	RET	Z
     772   00:E063  C3 BD DC            	JP	DSKSEL		;no. Select it then.
     773   00:E066                      ;
     774   00:E066                      ;   Check the drive selection and reset it to the previous
     775   00:E066                      ; drive if it was changed for the preceeding command.
     776   00:E066                      ;
     777   00:E066  3A F0 E3            RESETDR:LD	A,(CHGDRV)	;drive change indicated?
     778   00:E069  B7                  	OR	A
     779   00:E06A  C8                  	RET	Z
     780   00:E06B  3D                  	DEC	A		;yes, was it a different drive?
     781   00:E06C  21 EF E3            	LD	HL,CDRIVE
     782   00:E06F  BE                  	CP	(HL)
     783   00:E070  C8                  	RET	Z
     784   00:E071  3A EF E3            	LD	A,(CDRIVE)	;yes, re-select our old drive.
     785   00:E074  C3 BD DC            	JP	DSKSEL
     786   00:E077                      ;
     787   00:E077                      ;**************************************************************
     788   00:E077                      ;*
     789   00:E077                      ;*           D I R E C T O R Y   C O M M A N D
     790   00:E077                      ;*
     791   00:E077                      ;**************************************************************
     792   00:E077                      ;
     793   00:E077  CD 5E DE            DIRECT:	CALL	CONVFST		;convert file name.
     794   00:E07A  CD 54 E0            	CALL	DSELECT		;select indicated drive.
     795   00:E07D  21 CE E3            	LD	HL,FCB+1	;was any file indicated?
     796   00:E080  7E                  	LD	A,(HL)
     797   00:E081  FE 20               	CP	' '
     798   00:E083  C2 8F E0            	JP	NZ,DIRECT2
     799   00:E086  06 0B               	LD	B,11		;no. Fill field with '?' - same as *.*.
     800   00:E088  36 3F               DIRECT1:LD	(HL),'?'
     801   00:E08A  23                  	INC	HL
     802   00:E08B  05                  	DEC	B
     803   00:E08C  C2 88 E0            	JP	NZ,DIRECT1
     804   00:E08F  1E 00               DIRECT2:LD	E,0		;set initial cursor position.
     805   00:E091  D5                  	PUSH	DE
     806   00:E092  CD E9 DC            	CALL	SRCHFCB		;get first file name.
     807   00:E095  CC EA DF            	CALL	Z,NONE		;none found at all?
     808   00:E098  CA 1B E1            DIRECT3:JP	Z,DIRECT9	;terminate if no more names.
     809   00:E09B  3A EE E3            	LD	A,(RTNCODE)	;get file's position in segment (0-3).
     810   00:E09E  0F                  	RRCA	
     811   00:E09F  0F                  	RRCA	
     812   00:E0A0  0F                  	RRCA	
     813   00:E0A1  E6 60               	AND	60H		;(A)=position*32
     814   00:E0A3  4F                  	LD	C,A
     815   00:E0A4  3E 0A               	LD	A,10
     816   00:E0A6  CD 4B E0            	CALL	EXTRACT		;extract the tenth entry in fcb.
     817   00:E0A9  17                  	RLA			;check system file status bit.
     818   00:E0AA  DA 0F E1            	JP	C,DIRECT8	;we don't list them.
     819   00:E0AD  D1                  	POP	DE
     820   00:E0AE  7B                  	LD	A,E		;bump name count.
     821   00:E0AF  1C                  	INC	E
     822   00:E0B0  D5                  	PUSH	DE
     823   00:E0B1  E6 03               	AND	03H		;at end of line?
     824   00:E0B3  F5                  	PUSH	AF
     825   00:E0B4  C2 CC E0            	JP	NZ,DIRECT4
     826   00:E0B7  CD 98 DC            	CALL	CRLF		;yes, end this line and start another.
     827   00:E0BA  C5                  	PUSH	BC
     828   00:E0BB  CD D0 DD            	CALL	GETDSK		;start line with ('A:').
     829   00:E0BE  C1                  	POP	BC
     830   00:E0BF  C6 41               	ADD	A,'A'
     831   00:E0C1  CD 92 DC            	CALL	PRINTB
     832   00:E0C4  3E 3A               	LD	A,':'
     833   00:E0C6  CD 92 DC            	CALL	PRINTB
     834   00:E0C9  C3 D4 E0            	JP	DIRECT5
     835   00:E0CC  CD A2 DC            DIRECT4:CALL	SPACE		;add seperator between file names.
     836   00:E0CF  3E 3A               	LD	A,':'
     837   00:E0D1  CD 92 DC            	CALL	PRINTB
     838   00:E0D4  CD A2 DC            DIRECT5:CALL	SPACE
     839   00:E0D7  06 01               	LD	B,1		;'extract' each file name character at a time.
     840   00:E0D9  78                  DIRECT6:LD	A,B
     841   00:E0DA  CD 4B E0            	CALL	EXTRACT
     842   00:E0DD  E6 7F               	AND	7FH		;strip bit 7 (status bit).
     843   00:E0DF  FE 20               	CP	' '		;are we at the end of the name?
     844   00:E0E1  C2 F9 E0            	JP	NZ,DRECT65
     845   00:E0E4  F1                  	POP	AF		;yes, don't print spaces at the end of a line.
     846   00:E0E5  F5                  	PUSH	AF
     847   00:E0E6  FE 03               	CP	3
     848   00:E0E8  C2 F7 E0            	JP	NZ,DRECT63
     849   00:E0EB  3E 09               	LD	A,9		;first check for no extension.
     850   00:E0ED  CD 4B E0            	CALL	EXTRACT
     851   00:E0F0  E6 7F               	AND	7FH
     852   00:E0F2  FE 20               	CP	' '
     853   00:E0F4  CA 0E E1            	JP	Z,DIRECT7	;don't print spaces.
     854   00:E0F7  3E 20               DRECT63:LD	A,' '		;else print them.
     855   00:E0F9  CD 92 DC            DRECT65:CALL	PRINTB
     856   00:E0FC  04                  	INC	B		;bump to next character psoition.
     857   00:E0FD  78                  	LD	A,B
     858   00:E0FE  FE 0C               	CP	12		;end of the name?
     859   00:E100  D2 0E E1            	JP	NC,DIRECT7
     860   00:E103  FE 09               	CP	9		;nope, starting extension?
     861   00:E105  C2 D9 E0            	JP	NZ,DIRECT6
     862   00:E108  CD A2 DC            	CALL	SPACE		;yes, add seperating space.
     863   00:E10B  C3 D9 E0            	JP	DIRECT6
     864   00:E10E  F1                  DIRECT7:POP	AF		;get the next file name.
     865   00:E10F  CD C2 DD            DIRECT8:CALL	CHKCON		;first check console, quit on anything.
     866   00:E112  C2 1B E1            	JP	NZ,DIRECT9
     867   00:E115  CD E4 DC            	CALL	SRCHNXT		;get next name.
     868   00:E118  C3 98 E0            	JP	DIRECT3		;and continue with our list.
     869   00:E11B  D1                  DIRECT9:POP	DE		;restore the stack and return to command level.
     870   00:E11C  C3 86 E3            	JP	GETBACK
     871   00:E11F                      ;
     872   00:E11F                      ;**************************************************************
     873   00:E11F                      ;*
     874   00:E11F                      ;*                E R A S E   C O M M A N D
     875   00:E11F                      ;*
     876   00:E11F                      ;**************************************************************
     877   00:E11F                      ;
     878   00:E11F  CD 5E DE            ERASE:	CALL	CONVFST		;convert file name.
     879   00:E122  FE 0B               	CP	11		;was '*.*' entered?
     880   00:E124  C2 42 E1            	JP	NZ,ERASE1
     881   00:E127  01 52 E1            	LD	BC,YESNO	;yes, ask for confirmation.
     882   00:E12A  CD A7 DC            	CALL	PLINE
     883   00:E12D  CD 39 DD            	CALL	GETINP
     884   00:E130  21 07 DC            	LD	HL,INBUFF+1
     885   00:E133  35                  	DEC	(HL)		;must be exactly 'y'.
     886   00:E134  C2 82 DF            	JP	NZ,CMMND1
     887   00:E137  23                  	INC	HL
     888   00:E138  7E                  	LD	A,(HL)
     889   00:E139  FE 59               	CP	'Y'
     890   00:E13B  C2 82 DF            	JP	NZ,CMMND1
     891   00:E13E  23                  	INC	HL
     892   00:E13F  22 88 DC            	LD	(INPOINT),HL	;save input line pointer.
     893   00:E142  CD 54 E0            ERASE1:	CALL	DSELECT		;select desired disk.
     894   00:E145  11 CD E3            	LD	DE,FCB
     895   00:E148  CD EF DC            	CALL	DELETE		;delete the file.
     896   00:E14B  3C                  	INC	A
     897   00:E14C  CC EA DF            	CALL	Z,NONE		;not there?
     898   00:E14F  C3 86 E3            	JP	GETBACK		;return to command level now.
     899   00:E152                      YESNO:	DEFB	'All (y/n)?',0
     899   00:E152  41 6C 6C 20 28 79 2F 6E 29 3F 00 
     900   00:E15D                      ;
     901   00:E15D                      ;**************************************************************
     902   00:E15D                      ;*
     903   00:E15D                      ;*            T Y P E   C O M M A N D
     904   00:E15D                      ;*
     905   00:E15D                      ;**************************************************************
     906   00:E15D                      ;
     907   00:E15D  CD 5E DE            TYPE:	CALL	CONVFST		;convert file name.
     908   00:E160  C2 09 DE            	JP	NZ,SYNERR	;wild cards not allowed.
     909   00:E163  CD 54 E0            	CALL	DSELECT		;select indicated drive.
     910   00:E166  CD D0 DC            	CALL	OPENFCB		;open the file.
     911   00:E169  CA A7 E1            	JP	Z,TYPE5		;not there?
     912   00:E16C  CD 98 DC            	CALL	CRLF		;ok, start a new line on the screen.
     913   00:E16F  21 F1 E3            	LD	HL,NBYTES	;initialize byte counter.
     914   00:E172  36 FF               	LD	(HL),0FFH	;set to read first sector.
     915   00:E174  21 F1 E3            TYPE1:	LD	HL,NBYTES
     916   00:E177  7E                  TYPE2:	LD	A,(HL)		;have we written the entire sector?
     917   00:E178  FE 80               	CP	128
     918   00:E17A  DA 87 E1            	JP	C,TYPE3
     919   00:E17D  E5                  	PUSH	HL		;yes, read in the next one.
     920   00:E17E  CD FE DC            	CALL	READFCB
     921   00:E181  E1                  	POP	HL
     922   00:E182  C2 A0 E1            	JP	NZ,TYPE4	;end or error?
     923   00:E185  AF                  	XOR	A		;ok, clear byte counter.
     924   00:E186  77                  	LD	(HL),A
     925   00:E187  34                  TYPE3:	INC	(HL)		;count this byte.
     926   00:E188  21 80 00            	LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF).
     927   00:E18B  CD 59 DE            	CALL	ADDHL
     928   00:E18E  7E                  	LD	A,(HL)
     929   00:E18F  FE 1A               	CP	CNTRLZ		;end of file mark?
     930   00:E191  CA 86 E3            	JP	Z,GETBACK
     931   00:E194  CD 8C DC            	CALL	PRINT		;no, print it.
     932   00:E197  CD C2 DD            	CALL	CHKCON		;check console, quit if anything ready.
     933   00:E19A  C2 86 E3            	JP	NZ,GETBACK
     934   00:E19D  C3 74 E1            	JP	TYPE1
     935   00:E1A0                      ;
     936   00:E1A0                      ;   Get here on an end of file or read error.
     937   00:E1A0                      ;
     938   00:E1A0  3D                  TYPE4:	DEC	A		;read error?
     939   00:E1A1  CA 86 E3            	JP	Z,GETBACK
     940   00:E1A4  CD D9 DF            	CALL	RDERROR		;yes, print message.
     941   00:E1A7  CD 66 E0            TYPE5:	CALL	RESETDR		;and reset proper drive
     942   00:E1AA  C3 09 DE            	JP	SYNERR		;now print file name with problem.
     943   00:E1AD                      ;
     944   00:E1AD                      ;**************************************************************
     945   00:E1AD                      ;*
     946   00:E1AD                      ;*            S A V E   C O M M A N D
     947   00:E1AD                      ;*
     948   00:E1AD                      ;**************************************************************
     949   00:E1AD                      ;
     950   00:E1AD  CD F8 DF            SAVE:	CALL	DECODE		;get numeric number that follows SAVE.
     951   00:E1B0  F5                  	PUSH	AF		;save number of pages to write.
     952   00:E1B1  CD 5E DE            	CALL	CONVFST		;convert file name.
     953   00:E1B4  C2 09 DE            	JP	NZ,SYNERR	;wild cards not allowed.
     954   00:E1B7  CD 54 E0            	CALL	DSELECT		;select specified drive.
     955   00:E1BA  11 CD E3            	LD	DE,FCB		;now delete this file.
     956   00:E1BD  D5                  	PUSH	DE
     957   00:E1BE  CD EF DC            	CALL	DELETE
     958   00:E1C1  D1                  	POP	DE
     959   00:E1C2  CD 09 DD            	CALL	CREATE		;and create it again.
     960   00:E1C5  CA FB E1            	JP	Z,SAVE3		;can't create?
     961   00:E1C8  AF                  	XOR	A		;clear record number byte.
     962   00:E1C9  32 ED E3            	LD	(FCB+32),A
     963   00:E1CC  F1                  	POP	AF		;convert pages to sectors.
     964   00:E1CD  6F                  	LD	L,A
     965   00:E1CE  26 00               	LD	H,0
     966   00:E1D0  29                  	ADD	HL,HL		;(HL)=number of sectors to write.
     967   00:E1D1  11 00 80            	LD	DE,TBASE	;and we start from here.
     968   00:E1D4  7C                  SAVE1:	LD	A,H		;done yet?
     969   00:E1D5  B5                  	OR	L
     970   00:E1D6  CA F1 E1            	JP	Z,SAVE2
     971   00:E1D9  2B                  	DEC	HL		;nope, count this and compute the start
     972   00:E1DA  E5                  	PUSH	HL		;of the next 128 byte sector.
     973   00:E1DB  21 80 00            	LD	HL,128
     974   00:E1DE  19                  	ADD	HL,DE
     975   00:E1DF  E5                  	PUSH	HL		;save it and set the transfer address.
     976   00:E1E0  CD D8 DD            	CALL	DMASET
     977   00:E1E3  11 CD E3            	LD	DE,FCB		;write out this sector now.
     978   00:E1E6  CD 04 DD            	CALL	WRTREC
     979   00:E1E9  D1                  	POP	DE		;reset (DE) to the start of the last sector.
     980   00:E1EA  E1                  	POP	HL		;restore sector count.
     981   00:E1EB  C2 FB E1            	JP	NZ,SAVE3	;write error?
     982   00:E1EE  C3 D4 E1            	JP	SAVE1
     983   00:E1F1                      ;
     984   00:E1F1                      ;   Get here after writing all of the file.
     985   00:E1F1                      ;
     986   00:E1F1  11 CD E3            SAVE2:	LD	DE,FCB		;now close the file.
     987   00:E1F4  CD DA DC            	CALL	CLOSE
     988   00:E1F7  3C                  	INC	A		;did it close ok?
     989   00:E1F8  C2 01 E2            	JP	NZ,SAVE4
     990   00:E1FB                      ;
     991   00:E1FB                      ;   Print out error message (no space).
     992   00:E1FB                      ;
     993   00:E1FB  01 07 E2            SAVE3:	LD	BC,NOSPACE
     994   00:E1FE  CD A7 DC            	CALL	PLINE
     995   00:E201  CD D5 DD            SAVE4:	CALL	STDDMA		;reset the standard dma address.
     996   00:E204  C3 86 E3            	JP	GETBACK
     997   00:E207                      NOSPACE:DEFB	'No space',0
     997   00:E207  4E 6F 20 73 70 61 63 65 00 
     998   00:E210                      ;
     999   00:E210                      ;**************************************************************
    1000   00:E210                      ;*
    1001   00:E210                      ;*           R E N A M E   C O M M A N D
    1002   00:E210                      ;*
    1003   00:E210                      ;**************************************************************
    1004   00:E210                      ;
    1005   00:E210  CD 5E DE            RENAME:	CALL	CONVFST		;convert first file name.
    1006   00:E213  C2 09 DE            	JP	NZ,SYNERR	;wild cards not allowed.
    1007   00:E216  3A F0 E3            	LD	A,(CHGDRV)	;remember any change in drives specified.
    1008   00:E219  F5                  	PUSH	AF
    1009   00:E21A  CD 54 E0            	CALL	DSELECT		;and select this drive.
    1010   00:E21D  CD E9 DC            	CALL	SRCHFCB		;is this file present?
    1011   00:E220  C2 79 E2            	JP	NZ,RENAME6	;yes, print error message.
    1012   00:E223  21 CD E3            	LD	HL,FCB		;yes, move this name into second slot.
    1013   00:E226  11 DD E3            	LD	DE,FCB+16
    1014   00:E229  06 10               	LD	B,16
    1015   00:E22B  CD 42 E0            	CALL	HL2DE
    1016   00:E22E  2A 88 DC            	LD	HL,(INPOINT)	;get input pointer.
    1017   00:E231  EB                  	EX	DE,HL
    1018   00:E232  CD 4F DE            	CALL	NONBLANK	;get next non blank character.
    1019   00:E235  FE 3D               	CP	'='		;only allow an '=' or '_' seperator.
    1020   00:E237  CA 3F E2            	JP	Z,RENAME1
    1021   00:E23A  FE 5F               	CP	'_'
    1022   00:E23C  C2 73 E2            	JP	NZ,RENAME5
    1023   00:E23F  EB                  RENAME1:EX	DE,HL
    1024   00:E240  23                  	INC	HL		;ok, skip seperator.
    1025   00:E241  22 88 DC            	LD	(INPOINT),HL	;save input line pointer.
    1026   00:E244  CD 5E DE            	CALL	CONVFST		;convert this second file name now.
    1027   00:E247  C2 73 E2            	JP	NZ,RENAME5	;again, no wild cards.
    1028   00:E24A  F1                  	POP	AF		;if a drive was specified, then it
    1029   00:E24B  47                  	LD	B,A		;must be the same as before.
    1030   00:E24C  21 F0 E3            	LD	HL,CHGDRV
    1031   00:E24F  7E                  	LD	A,(HL)
    1032   00:E250  B7                  	OR	A
    1033   00:E251  CA 59 E2            	JP	Z,RENAME2
    1034   00:E254  B8                  	CP	B
    1035   00:E255  70                  	LD	(HL),B
    1036   00:E256  C2 73 E2            	JP	NZ,RENAME5	;they were different, error.
    1037   00:E259  70                  RENAME2:LD	(HL),B		;	reset as per the first file specification.
    1038   00:E25A  AF                  	XOR	A
    1039   00:E25B  32 CD E3            	LD	(FCB),A		;clear the drive byte of the fcb.
    1040   00:E25E  CD E9 DC            RENAME3:CALL	SRCHFCB		;and go look for second file.
    1041   00:E261  CA 6D E2            	JP	Z,RENAME4	;doesn't exist?
    1042   00:E264  11 CD E3            	LD	DE,FCB
    1043   00:E267  CD 0E DD            	CALL	RENAM		;ok, rename the file.
    1044   00:E26A  C3 86 E3            	JP	GETBACK
    1045   00:E26D                      ;
    1046   00:E26D                      ;   Process rename errors here.
    1047   00:E26D                      ;
    1048   00:E26D  CD EA DF            RENAME4:CALL	NONE		;file not there.
    1049   00:E270  C3 86 E3            	JP	GETBACK
    1050   00:E273  CD 66 E0            RENAME5:CALL	RESETDR		;bad command format.
    1051   00:E276  C3 09 DE            	JP	SYNERR
    1052   00:E279  01 82 E2            RENAME6:LD	BC,EXISTS	;destination file already exists.
    1053   00:E27C  CD A7 DC            	CALL	PLINE
    1054   00:E27F  C3 86 E3            	JP	GETBACK
    1055   00:E282                      EXISTS:	DEFB	'File exists',0
    1055   00:E282  46 69 6C 65 20 65 78 69 73 74 73 00 
    1056   00:E28E                      ;
    1057   00:E28E                      ;**************************************************************
    1058   00:E28E                      ;*
    1059   00:E28E                      ;*             U S E R   C O M M A N D
    1060   00:E28E                      ;*
    1061   00:E28E                      ;**************************************************************
    1062   00:E28E                      ;
    1063   00:E28E  CD F8 DF            USER:	CALL	DECODE		;get numeric value following command.
    1064   00:E291  FE 10               	CP	16		;legal user number?
    1065   00:E293  D2 09 DE            	JP	NC,SYNERR
    1066   00:E296  5F                  	LD	E,A		;yes but is there anything else?
    1067   00:E297  3A CE E3            	LD	A,(FCB+1)
    1068   00:E29A  FE 20               	CP	' '
    1069   00:E29C  CA 09 DE            	JP	Z,SYNERR	;yes, that is not allowed.
    1070   00:E29F  CD 15 DD            	CALL	GETSETUC	;ok, set user code.
    1071   00:E2A2  C3 89 E3            	JP	GETBACK1
    1072   00:E2A5                      ;
    1073   00:E2A5                      ;**************************************************************
    1074   00:E2A5                      ;*
    1075   00:E2A5                      ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
    1076   00:E2A5                      ;*
    1077   00:E2A5                      ;**************************************************************
    1078   00:E2A5                      ;
    1079   00:E2A5  CD F5 DD            UNKNOWN:CALL	VERIFY		;check for valid system (why?).
    1080   00:E2A8  3A CE E3            	LD	A,(FCB+1)	;anything to execute?
    1081   00:E2AB  FE 20               	CP	' '
    1082   00:E2AD  C2 C4 E2            	JP	NZ,UNKWN1
    1083   00:E2B0  3A F0 E3            	LD	A,(CHGDRV)	;nope, only a drive change?
    1084   00:E2B3  B7                  	OR	A
    1085   00:E2B4  CA 89 E3            	JP	Z,GETBACK1	;neither???
    1086   00:E2B7  3D                  	DEC	A
    1087   00:E2B8  32 EF E3            	LD	(CDRIVE),A	;ok, store new drive.
    1088   00:E2BB  CD 29 DD            	CALL	MOVECD		;set (TDRIVE) also.
    1089   00:E2BE  CD BD DC            	CALL	DSKSEL		;and select this drive.
    1090   00:E2C1  C3 89 E3            	JP	GETBACK1	;then return.
    1091   00:E2C4                      ;
    1092   00:E2C4                      ;   Here a file name was typed. Prepare to execute it.
    1093   00:E2C4                      ;
    1094   00:E2C4  11 D6 E3            UNKWN1:	LD	DE,FCB+9	;an extension specified?
    1095   00:E2C7  1A                  	LD	A,(DE)
    1096   00:E2C8  FE 20               	CP	' '
    1097   00:E2CA  C2 09 DE            	JP	NZ,SYNERR	;yes, not allowed.
    1098   00:E2CD  D5                  UNKWN2:	PUSH	DE
    1099   00:E2CE  CD 54 E0            	CALL	DSELECT		;select specified drive.
    1100   00:E2D1  D1                  	POP	DE
    1101   00:E2D2  21 83 E3            	LD	HL,COMFILE	;set the extension to 'COM'.
    1102   00:E2D5  CD 40 E0            	CALL	MOVE3
    1103   00:E2D8  CD D0 DC            	CALL	OPENFCB		;and open this file.
    1104   00:E2DB  CA 6B E3            	JP	Z,UNKWN9	;not present?
    1105   00:E2DE                      ;
    1106   00:E2DE                      ;   Load in the program.
    1107   00:E2DE                      ;
    1108   00:E2DE  21 00 80            	LD	HL,TBASE	;store the program starting here.
    1109   00:E2E1  E5                  UNKWN3:	PUSH	HL
    1110   00:E2E2  EB                  	EX	DE,HL
    1111   00:E2E3  CD D8 DD            	CALL	DMASET		;set transfer address.
    1112   00:E2E6  11 CD E3            	LD	DE,FCB		;and read the next record.
    1113   00:E2E9  CD F9 DC            	CALL	RDREC
    1114   00:E2EC  C2 01 E3            	JP	NZ,UNKWN4	;end of file or read error?
    1115   00:E2EF  E1                  	POP	HL		;nope, bump pointer for next sector.
    1116   00:E2F0  11 80 00            	LD	DE,128
    1117   00:E2F3  19                  	ADD	HL,DE
    1118   00:E2F4  11 00 DC            	LD	DE,CBASE	;enough room for the whole file?
    1119   00:E2F7  7D                  	LD	A,L
    1120   00:E2F8  93                  	SUB	E
    1121   00:E2F9  7C                  	LD	A,H
    1122   00:E2FA  9A                  	SBC	A,D
    1123   00:E2FB  D2 71 E3            	JP	NC,UNKWN0	;no, it can't fit.
    1124   00:E2FE  C3 E1 E2            	JP	UNKWN3
    1125   00:E301                      ;
    1126   00:E301                      ;   Get here after finished reading.
    1127   00:E301                      ;
    1128   00:E301  E1                  UNKWN4:	POP	HL
    1129   00:E302  3D                  	DEC	A		;normal end of file?
    1130   00:E303  C2 71 E3            	JP	NZ,UNKWN0
    1131   00:E306  CD 66 E0            	CALL	RESETDR		;yes, reset previous drive.
    1132   00:E309  CD 5E DE            	CALL	CONVFST		;convert the first file name that follows
    1133   00:E30C  21 F0 E3            	LD	HL,CHGDRV	;command name.
    1134   00:E30F  E5                  	PUSH	HL
    1135   00:E310  7E                  	LD	A,(HL)		;set drive code in default fcb.
    1136   00:E311  32 CD E3            	LD	(FCB),A
    1137   00:E314  3E 10               	LD	A,16		;put second name 16 bytes later.
    1138   00:E316  CD 60 DE            	CALL	CONVERT		;convert second file name.
    1139   00:E319  E1                  	POP	HL
    1140   00:E31A  7E                  	LD	A,(HL)		;and set the drive for this second file.
    1141   00:E31B  32 DD E3            	LD	(FCB+16),A
    1142   00:E31E  AF                  	XOR	A		;clear record byte in fcb.
    1143   00:E31F  32 ED E3            	LD	(FCB+32),A
    1144   00:E322  11 5C 00            	LD	DE,TFCB		;move it into place at(005Ch).
    1145   00:E325  21 CD E3            	LD	HL,FCB
    1146   00:E328  06 21               	LD	B,33
    1147   00:E32A  CD 42 E0            	CALL	HL2DE
    1148   00:E32D  21 08 DC            	LD	HL,INBUFF+2	;now move the remainder of the input
    1149   00:E330  7E                  UNKWN5:	LD	A,(HL)		;line down to (0080h). Look for a non blank.
    1150   00:E331  B7                  	OR	A		;or a null.
    1151   00:E332  CA 3E E3            	JP	Z,UNKWN6
    1152   00:E335  FE 20               	CP	' '
    1153   00:E337  CA 3E E3            	JP	Z,UNKWN6
    1154   00:E33A  23                  	INC	HL
    1155   00:E33B  C3 30 E3            	JP	UNKWN5
    1156   00:E33E                      ;
    1157   00:E33E                      ;   Do the line move now. It ends in a null byte.
    1158   00:E33E                      ;
    1159   00:E33E  06 00               UNKWN6:	LD	B,0		;keep a character count.
    1160   00:E340  11 81 00            	LD	DE,TBUFF+1	;data gets put here.
    1161   00:E343  7E                  UNKWN7:	LD	A,(HL)		;move it now.
    1162   00:E344  12                  	LD	(DE),A
    1163   00:E345  B7                  	OR	A
    1164   00:E346  CA 4F E3            	JP	Z,UNKWN8
    1165   00:E349  04                  	INC	B
    1166   00:E34A  23                  	INC	HL
    1167   00:E34B  13                  	INC	DE
    1168   00:E34C  C3 43 E3            	JP	UNKWN7
    1169   00:E34F  78                  UNKWN8:	LD	A,B		;now store the character count.
    1170   00:E350  32 80 00            	LD	(TBUFF),A
    1171   00:E353  CD 98 DC            	CALL	CRLF		;clean up the screen.
    1172   00:E356  CD D5 DD            	CALL	STDDMA		;set standard transfer address.
    1173   00:E359  CD 1A DD            	CALL	SETCDRV		;reset current drive.
    1174   00:E35C  CD 00 80            	CALL	TBASE		;and execute the program.
    1175   00:E35F                      ;
    1176   00:E35F                      ;   Transiant programs return here (or reboot).
    1177   00:E35F                      ;
    1178   00:E35F  31 AB E3            	LD	SP,BATCH	;set stack first off.
    1179   00:E362  CD 29 DD            	CALL	MOVECD		;move current drive into place (TDRIVE).
    1180   00:E365  CD BD DC            	CALL	DSKSEL		;and reselect it.
    1181   00:E368  C3 82 DF            	JP	CMMND1		;back to comand mode.
    1182   00:E36B                      ;
    1183   00:E36B                      ;   Get here if some error occured.
    1184   00:E36B                      ;
    1185   00:E36B  CD 66 E0            UNKWN9:	CALL	RESETDR		;inproper format.
    1186   00:E36E  C3 09 DE            	JP	SYNERR
    1187   00:E371  01 7A E3            UNKWN0:	LD	BC,BADLOAD	;read error or won't fit.
    1188   00:E374  CD A7 DC            	CALL	PLINE
    1189   00:E377  C3 86 E3            	JP	GETBACK
    1190   00:E37A                      BADLOAD:DEFB	'Bad load',0
    1190   00:E37A  42 61 64 20 6C 6F 61 64 00 
    1191   00:E383  43 4F 4D            COMFILE:DEFB	'COM'		;command file extension.
    1192   00:E386                      ;
    1193   00:E386                      ;   Get here to return to command level. We will reset the
    1194   00:E386                      ; previous active drive and then either return to command
    1195   00:E386                      ; level directly or print error message and then return.
    1196   00:E386                      ;
    1197   00:E386  CD 66 E0            GETBACK:CALL	RESETDR		;reset previous drive.
    1198   00:E389  CD 5E DE            GETBACK1: CALL	CONVFST		;convert first name in (FCB).
    1199   00:E38C  3A CE E3            	LD	A,(FCB+1)	;if this was just a drive change request,
    1200   00:E38F  D6 20               	SUB	' '		;make sure it was valid.
    1201   00:E391  21 F0 E3            	LD	HL,CHGDRV
    1202   00:E394  B6                  	OR	(HL)
    1203   00:E395  C2 09 DE            	JP	NZ,SYNERR
    1204   00:E398  C3 82 DF            	JP	CMMND1		;ok, return to command level.
    1205   00:E39B                      ;
    1206   00:E39B                      ;   ccp stack area.
    1207   00:E39B                      ;
    1208   00:E39B                      	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    1208   00:E39B  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
    1209   00:E3AB  (00:FFFF)           CCPSTACK EQU	0FFFFH	;end of ccp stack area.
    1210   00:E3AB                      ;
    1211   00:E3AB                      ;   Batch (or SUBMIT) processing information storage.
    1212   00:E3AB                      ;
    1213   00:E3AB  00                  BATCH:	DEFB	0		;batch mode flag (0=not active).
    1214   00:E3AC                      BATCHFCB: DEFB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    1214   00:E3AC  00 24 24 24 20 20 20 20 20 53 55 42 00 00 00 00 
    1214   00:E3BC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
    1214   00:E3CC  00 
    1215   00:E3CD                      ;
    1216   00:E3CD                      ;   File control block setup by the CCP.
    1217   00:E3CD                      ;
    1218   00:E3CD                      FCB:	DEFB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
    1218   00:E3CD  00 20 20 20 20 20 20 20 20 20 20 20 00 00 00 00 
    1218   00:E3DD  00 20 20 20 20 20 20 20 20 20 20 20 00 00 00 00 
    1218   00:E3ED  00 
    1219   00:E3EE  00                  RTNCODE:DEFB	0		;status returned from bdos call.
    1220   00:E3EF  00                  CDRIVE:	DEFB	0		;currently active drive.
    1221   00:E3F0  00                  CHGDRV:	DEFB	0		;change in drives flag (0=no change).
    1222   00:E3F1  00 00               NBYTES:	DEFW	0		;byte counter used by TYPE.
    1223   00:E3F3                      ;
    1224   00:E3F3                      ;   Room for expansion?
    1225   00:E3F3                      ;
    1226   00:E3F3                      	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0
    1226   00:E3F3  00 00 00 00 00 00 00 00 00 00 00 00 00 
    1227   00:E400                      ;
    1228   00:E400                      ;   Note that the following six bytes must match those at
    1229   00:E400                      ; (PATTRN1) or cp/m will HALT. Why?
    1230   00:E400                      ;
    1231   00:E400  00 16 00 00 00 00   PATTRN2:DEFB	0,22,0,0,0,0	;(* serial number bytes *).
    1232   00:E406                      ;
    1233   00:E406                      ;**************************************************************
    1234   00:E406                      ;*
    1235   00:E406                      ;*                    B D O S   E N T R Y
    1236   00:E406                      ;*
    1237   00:E406                      ;**************************************************************
    1238   00:E406                      ;
    1239   00:E406  C3 11 E4            FBASE:	JP	FBASE1
    1240   00:E409                      ;
    1241   00:E409                      ;   Bdos error table.
    1242   00:E409                      ;
    1243   00:E409  99 E4               BADSCTR:DEFW	ERROR1		;bad sector on read or write.
    1244   00:E40B  A5 E4               BADSLCT:DEFW	ERROR2		;bad disk select.
    1245   00:E40D  AB E4               RODISK:	DEFW	ERROR3		;disk is read only.
    1246   00:E40F  B1 E4               ROFILE:	DEFW	ERROR4		;file is read only.
    1247   00:E411                      ;
    1248   00:E411                      ;   Entry into bdos. (DE) or (E) are the parameters passed. The
    1249   00:E411                      ; function number desired is in register (C).
    1250   00:E411                      ;
    1251   00:E411  EB                  FBASE1:	EX	DE,HL		;save the (DE) parameters.
    1252   00:E412  22 43 E7            	LD	(PARAMS),HL
    1253   00:E415  EB                  	EX	DE,HL
    1254   00:E416  7B                  	LD	A,E		;and save register (E) in particular.
    1255   00:E417  32 D5 F1            	LD	(EPARAM),A
    1256   00:E41A  21 00 00            	LD	HL,0
    1257   00:E41D  22 45 E7            	LD	(STATUS),HL	;clear return status.
    1258   00:E420  39                  	ADD	HL,SP
    1259   00:E421  22 0F E7            	LD	(USRSTACK),HL	;save users stack pointer.
    1260   00:E424  31 41 E7            	LD	SP,STKAREA	;and set our own.
    1261   00:E427  AF                  	XOR	A		;clear auto select storage space.
    1262   00:E428  32 DF F1            	LD	(AUTOFLAG),A
    1263   00:E42B  32 DD F1            	LD	(AUTO),A
    1264   00:E42E  21 73 F1            	LD	HL,GOBACK	;set return address.
    1265   00:E431  E5                  	PUSH	HL
    1266   00:E432  79                  	LD	A,C		;get function number.
    1267   00:E433  FE 29               	CP	NFUNCTS		;valid function number?
    1268   00:E435  D0                  	RET	NC
    1269   00:E436  4B                  	LD	C,E		;keep single register function here.
    1270   00:E437  21 47 E4            	LD	HL,FUNCTNS	;now look thru the function table.
    1271   00:E43A  5F                  	LD	E,A
    1272   00:E43B  16 00               	LD	D,0		;(DE)=function number.
    1273   00:E43D  19                  	ADD	HL,DE
    1274   00:E43E  19                  	ADD	HL,DE		;(HL)=(start of table)+2*(function number).
    1275   00:E43F  5E                  	LD	E,(HL)
    1276   00:E440  23                  	INC	HL
    1277   00:E441  56                  	LD	D,(HL)		;now (DE)=address for this function.
    1278   00:E442  2A 43 E7            	LD	HL,(PARAMS)	;retrieve parameters.
    1279   00:E445  EB                  	EX	DE,HL		;now (DE) has the original parameters.
    1280   00:E446  E9                  	JP	(HL)		;execute desired function.
    1281   00:E447                      ;
    1282   00:E447                      ;   BDOS function jump table.
    1283   00:E447                      ;
    1284   00:E447  (00:0029)           NFUNCTS EQU	41		;number of functions in followin table.
    1285   00:E447                      ;
    1286   00:E447                      FUNCTNS:DEFW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
    1286   00:E447  02 F2 C8 E6 90 E5 CE E6 11 F2 0E F2 D4 E6 ED E6 
    1287   00:E457                      	DEFW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
    1287   00:E457  F3 E6 F8 E6 E1 E5 FE E6 7D F0 82 F0 44 F0 9B F0 
    1288   00:E467                      	DEFW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
    1288   00:E467  A4 F0 AA F0 C7 F0 D6 F0 DF F0 E5 F0 EB F0 
    1289   00:E475                      	DEFW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
    1289   00:E475  F4 F0 FD F0 03 F1 09 F1 10 F1 2D E9 16 F1 1C F1 
    1290   00:E485                      	DEFW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
    1290   00:E485  25 F1 2C F1 40 F1 46 F1 4C F1 0D F0 52 F1 04 E7 
    1291   00:E495  04 E7 9A F1         	DEFW	RTN,WTSPECL
    1292   00:E499                      ;
    1293   00:E499                      ;   Bdos error message section.
    1294   00:E499                      ;
    1295   00:E499  21 CA E4            ERROR1:	LD	HL,BADSEC	;bad sector message.
    1296   00:E49C  CD E5 E4            	CALL	PRTERR		;print it and get a 1 char responce.
    1297   00:E49F  FE 03               	CP	CNTRLC		;re-boot request (control-c)?
    1298   00:E4A1  CA 00 00            	JP	Z,0		;yes.
    1299   00:E4A4  C9                  	RET			;no, return to retry i/o function.
    1300   00:E4A5                      ;
    1301   00:E4A5  21 D5 E4            ERROR2:	LD	HL,BADSEL	;bad drive selected.
    1302   00:E4A8  C3 B4 E4            	JP	ERROR5
    1303   00:E4AB                      ;
    1304   00:E4AB  21 E1 E4            ERROR3:	LD	HL,DISKRO	;disk is read only.
    1305   00:E4AE  C3 B4 E4            	JP	ERROR5
    1306   00:E4B1                      ;
    1307   00:E4B1  21 DC E4            ERROR4:	LD	HL,FILERO	;file is read only.
    1308   00:E4B4                      ;
    1309   00:E4B4  CD E5 E4            ERROR5:	CALL	PRTERR
    1310   00:E4B7  C3 00 00            	JP	0		;always reboot on these errors.
    1311   00:E4BA                      ;
    1312   00:E4BA                      BDOSERR:DEFB	'Bdos Err On '
    1312   00:E4BA  42 64 6F 73 20 45 72 72 20 4F 6E 20 
    1313   00:E4C6  20 3A 20 24         BDOSDRV:DEFB	' : $'
    1314   00:E4CA                      BADSEC:	DEFB	'Bad Sector$'
    1314   00:E4CA  42 61 64 20 53 65 63 74 6F 72 24 
    1315   00:E4D5                      BADSEL:	DEFB	'Select$'
    1315   00:E4D5  53 65 6C 65 63 74 24 
    1316   00:E4DC  46 69 6C 65 20      FILERO:	DEFB	'File '
    1317   00:E4E1  52 2F 4F 24         DISKRO:	DEFB	'R/O$'
    1318   00:E4E5                      ;
    1319   00:E4E5                      ;   Print bdos error message.
    1320   00:E4E5                      ;
    1321   00:E4E5  E5                  PRTERR:	PUSH	HL		;save second message pointer.
    1322   00:E4E6  CD C9 E5            	CALL	OUTCRLF		;send (cr)(lf).
    1323   00:E4E9  3A 42 E7            	LD	A,(ACTIVE)	;get active drive.
    1324   00:E4EC  C6 41               	ADD	A,'A'		;make ascii.
    1325   00:E4EE  32 C6 E4            	LD	(BDOSDRV),A	;and put in message.
    1326   00:E4F1  01 BA E4            	LD	BC,BDOSERR	;and print it.
    1327   00:E4F4  CD D3 E5            	CALL	PRTMESG
    1328   00:E4F7  C1                  	POP	BC		;print second message line now.
    1329   00:E4F8  CD D3 E5            	CALL	PRTMESG
    1330   00:E4FB                      ;
    1331   00:E4FB                      ;   Get an input character. We will check our 1 character
    1332   00:E4FB                      ; buffer first. This may be set by the console status routine.
    1333   00:E4FB                      ;
    1334   00:E4FB  21 0E E7            GETCHAR:LD	HL,CHARBUF	;check character buffer.
    1335   00:E4FE  7E                  	LD	A,(HL)		;anything present already?
    1336   00:E4FF  36 00               	LD	(HL),0		;...either case clear it.
    1337   00:E501  B7                  	OR	A
    1338   00:E502  C0                  	RET	NZ		;yes, use it.
    1339   00:E503  C3 08 F2            	JP	CONIN		;nope, go get a character responce.
    1340   00:E506                      ;
    1341   00:E506                      ;   Input and echo a character.
    1342   00:E506                      ;
    1343   00:E506  CD FB E4            GETECHO:CALL	GETCHAR		;input a character.
    1344   00:E509  CD 14 E5            	CALL	CHKCHAR		;carriage control?
    1345   00:E50C  D8                  	RET	C		;no, a regular control char so don't echo.
    1346   00:E50D  F5                  	PUSH	AF		;ok, save character now.
    1347   00:E50E  4F                  	LD	C,A
    1348   00:E50F  CD 90 E5            	CALL	OUTCON		;and echo it.
    1349   00:E512  F1                  	POP	AF		;get character and return.
    1350   00:E513  C9                  	RET	
    1351   00:E514                      ;
    1352   00:E514                      ;   Check character in (A). Set the zero flag on a carriage
    1353   00:E514                      ; control character and the carry flag on any other control
    1354   00:E514                      ; character.
    1355   00:E514                      ;
    1356   00:E514  FE 0D               CHKCHAR:CP	CR		;check for carriage return, line feed, backspace,
    1357   00:E516  C8                  	RET	Z		;or a tab.
    1358   00:E517  FE 0A               	CP	LF
    1359   00:E519  C8                  	RET	Z
    1360   00:E51A  FE 09               	CP	TAB
    1361   00:E51C  C8                  	RET	Z
    1362   00:E51D  FE 08               	CP	BS
    1363   00:E51F  C8                  	RET	Z
    1364   00:E520  FE 20               	CP	' '		;other control char? Set carry flag.
    1365   00:E522  C9                  	RET	
    1366   00:E523                      ;
    1367   00:E523                      ;   Check the console during output. Halt on a control-s, then
    1368   00:E523                      ; reboot on a control-c. If anything else is ready, clear the
    1369   00:E523                      ; zero flag and return (the calling routine may want to do
    1370   00:E523                      ; something).
    1371   00:E523                      ;
    1372   00:E523  3A 0E E7            CKCONSOL: LD	A,(CHARBUF)	;check buffer.
    1373   00:E526  B7                  	OR	A		;if anything, just return without checking.
    1374   00:E527  C2 45 E5            	JP	NZ,CKCON2
    1375   00:E52A  CD 05 F2            	CALL	CONST		;nothing in buffer. Check console.
    1376   00:E52D  E6 01               	AND	01H		;look at bit 0.
    1377   00:E52F  C8                  	RET	Z		;return if nothing.
    1378   00:E530  CD 08 F2            	CALL	CONIN		;ok, get it.
    1379   00:E533  FE 13               	CP	CNTRLS		;if not control-s, return with zero cleared.
    1380   00:E535  C2 42 E5            	JP	NZ,CKCON1
    1381   00:E538  CD 08 F2            	CALL	CONIN		;halt processing until another char
    1382   00:E53B  FE 03               	CP	CNTRLC		;is typed. Control-c?
    1383   00:E53D  CA 00 00            	JP	Z,0		;yes, reboot now.
    1384   00:E540  AF                  	XOR	A		;no, just pretend nothing was ever ready.
    1385   00:E541  C9                  	RET	
    1386   00:E542  32 0E E7            CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing.
    1387   00:E545  3E 01               CKCON2:	LD	A,1		;set (A) to non zero to mean something is ready.
    1388   00:E547  C9                  	RET	
    1389   00:E548                      ;
    1390   00:E548                      ;   Output (C) to the screen. If the printer flip-flop flag
    1391   00:E548                      ; is set, we will send character to printer also. The console
    1392   00:E548                      ; will be checked in the process.
    1393   00:E548                      ;
    1394   00:E548  3A 0A E7            OUTCHAR:LD	A,(OUTFLAG)	;check output flag.
    1395   00:E54B  B7                  	OR	A		;anything and we won't generate output.
    1396   00:E54C  C2 62 E5            	JP	NZ,OUTCHR1
    1397   00:E54F  C5                  	PUSH	BC
    1398   00:E550  CD 23 E5            	CALL	CKCONSOL	;check console (we don't care whats there).
    1399   00:E553  C1                  	POP	BC
    1400   00:E554  C5                  	PUSH	BC
    1401   00:E555  CD 0B F2            	CALL	CONOUT		;output (C) to the screen.
    1402   00:E558  C1                  	POP	BC
    1403   00:E559  C5                  	PUSH	BC
    1404   00:E55A  3A 0D E7            	LD	A,(PRTFLAG)	;check printer flip-flop flag.
    1405   00:E55D  B7                  	OR	A
    1406   00:E55E  C4 0E F2            	CALL	NZ,LIST		;print it also if non-zero.
    1407   00:E561  C1                  	POP	BC
    1408   00:E562  79                  OUTCHR1:LD	A,C		;update cursors position.
    1409   00:E563  21 0C E7            	LD	HL,CURPOS
    1410   00:E566  FE 7F               	CP	DEL		;rubouts don't do anything here.
    1411   00:E568  C8                  	RET	Z
    1412   00:E569  34                  	INC	(HL)		;bump line pointer.
    1413   00:E56A  FE 20               	CP	' '		;and return if a normal character.
    1414   00:E56C  D0                  	RET	NC
    1415   00:E56D  35                  	DEC	(HL)		;restore and check for the start of the line.
    1416   00:E56E  7E                  	LD	A,(HL)
    1417   00:E56F  B7                  	OR	A
    1418   00:E570  C8                  	RET	Z		;ingnore control characters at the start of the line.
    1419   00:E571  79                  	LD	A,C
    1420   00:E572  FE 08               	CP	BS		;is it a backspace?
    1421   00:E574  C2 79 E5            	JP	NZ,OUTCHR2
    1422   00:E577  35                  	DEC	(HL)		;yes, backup pointer.
    1423   00:E578  C9                  	RET	
    1424   00:E579  FE 0A               OUTCHR2:CP	LF		;is it a line feed?
    1425   00:E57B  C0                  	RET	NZ		;ignore anything else.
    1426   00:E57C  36 00               	LD	(HL),0		;reset pointer to start of line.
    1427   00:E57E  C9                  	RET	
    1428   00:E57F                      ;
    1429   00:E57F                      ;   Output (A) to the screen. If it is a control character
    1430   00:E57F                      ; (other than carriage control), use ^x format.
    1431   00:E57F                      ;
    1432   00:E57F  79                  SHOWIT:	LD	A,C
    1433   00:E580  CD 14 E5            	CALL	CHKCHAR		;check character.
    1434   00:E583  D2 90 E5            	JP	NC,OUTCON	;not a control, use normal output.
    1435   00:E586  F5                  	PUSH	AF
    1436   00:E587  0E 5E               	LD	C,'^'		;for a control character, preceed it with '^'.
    1437   00:E589  CD 48 E5            	CALL	OUTCHAR
    1438   00:E58C  F1                  	POP	AF
    1439   00:E58D  F6 40               	OR	'@'		;and then use the letter equivelant.
    1440   00:E58F  4F                  	LD	C,A
    1441   00:E590                      ;
    1442   00:E590                      ;   Function to output (C) to the console device and expand tabs
    1443   00:E590                      ; if necessary.
    1444   00:E590                      ;
    1445   00:E590  79                  OUTCON:	LD	A,C
    1446   00:E591  FE 09               	CP	TAB		;is it a tab?
    1447   00:E593  C2 48 E5            	JP	NZ,OUTCHAR	;use regular output.
    1448   00:E596  0E 20               OUTCON1:LD	C,' '		;yes it is, use spaces instead.
    1449   00:E598  CD 48 E5            	CALL	OUTCHAR
    1450   00:E59B  3A 0C E7            	LD	A,(CURPOS)	;go until the cursor is at a multiple of 8
    1451   00:E59E                      
    1452   00:E59E  E6 07               	AND	07H		;position.
    1453   00:E5A0  C2 96 E5            	JP	NZ,OUTCON1
    1454   00:E5A3  C9                  	RET	
    1455   00:E5A4                      ;
    1456   00:E5A4                      ;   Echo a backspace character. Erase the prevoius character
    1457   00:E5A4                      ; on the screen.
    1458   00:E5A4                      ;
    1459   00:E5A4  CD AC E5            BACKUP:	CALL	BACKUP1		;backup the screen 1 place.
    1460   00:E5A7  0E 20               	LD	C,' '		;then blank that character.
    1461   00:E5A9  CD 0B F2            	CALL	CONOUT
    1462   00:E5AC  0E 08               BACKUP1:LD	C,BS		;then back space once more.
    1463   00:E5AE  C3 0B F2            	JP	CONOUT
    1464   00:E5B1                      ;
    1465   00:E5B1                      ;   Signal a deleted line. Print a '#' at the end and start
    1466   00:E5B1                      ; over.
    1467   00:E5B1                      ;
    1468   00:E5B1  0E 23               NEWLINE:LD	C,'#'
    1469   00:E5B3  CD 48 E5            	CALL	OUTCHAR		;print this.
    1470   00:E5B6  CD C9 E5            	CALL	OUTCRLF		;start new line.
    1471   00:E5B9  3A 0C E7            NEWLN1:	LD	A,(CURPOS)	;move the cursor to the starting position.
    1472   00:E5BC  21 0B E7            	LD	HL,STARTING
    1473   00:E5BF  BE                  	CP	(HL)
    1474   00:E5C0  D0                  	RET	NC		;there yet?
    1475   00:E5C1  0E 20               	LD	C,' '
    1476   00:E5C3  CD 48 E5            	CALL	OUTCHAR		;nope, keep going.
    1477   00:E5C6  C3 B9 E5            	JP	NEWLN1
    1478   00:E5C9                      ;
    1479   00:E5C9                      ;   Output a (cr) (lf) to the console device (screen).
    1480   00:E5C9                      ;
    1481   00:E5C9  0E 0D               OUTCRLF:LD	C,CR
    1482   00:E5CB  CD 48 E5            	CALL	OUTCHAR
    1483   00:E5CE  0E 0A               	LD	C,LF
    1484   00:E5D0  C3 48 E5            	JP	OUTCHAR
    1485   00:E5D3                      ;
    1486   00:E5D3                      ;   Print message pointed to by (BC). It will end with a '$'.
    1487   00:E5D3                      ;
    1488   00:E5D3  0A                  PRTMESG:LD	A,(BC)		;check for terminating character.
    1489   00:E5D4  FE 24               	CP	'$'
    1490   00:E5D6  C8                  	RET	Z
    1491   00:E5D7  03                  	INC	BC
    1492   00:E5D8  C5                  	PUSH	BC		;otherwise, bump pointer and print it.
    1493   00:E5D9  4F                  	LD	C,A
    1494   00:E5DA  CD 90 E5            	CALL	OUTCON
    1495   00:E5DD  C1                  	POP	BC
    1496   00:E5DE  C3 D3 E5            	JP	PRTMESG
    1497   00:E5E1                      ;
    1498   00:E5E1                      ;   Function to execute a buffered read.
    1499   00:E5E1                      ;
    1500   00:E5E1  3A 0C E7            RDBUFF:	LD	A,(CURPOS)	;use present location as starting one.
    1501   00:E5E4  32 0B E7            	LD	(STARTING),A
    1502   00:E5E7  2A 43 E7            	LD	HL,(PARAMS)	;get the maximum buffer space.
    1503   00:E5EA  4E                  	LD	C,(HL)
    1504   00:E5EB  23                  	INC	HL		;point to first available space.
    1505   00:E5EC  E5                  	PUSH	HL		;and save.
    1506   00:E5ED  06 00               	LD	B,0		;keep a character count.
    1507   00:E5EF  C5                  RDBUF1:	PUSH	BC
    1508   00:E5F0  E5                  	PUSH	HL
    1509   00:E5F1  CD FB E4            RDBUF2:	CALL	GETCHAR		;get the next input character.
    1510   00:E5F4  E6 7F               	AND	7FH		;strip bit 7.
    1511   00:E5F6  E1                  	POP	HL		;reset registers.
    1512   00:E5F7  C1                  	POP	BC
    1513   00:E5F8  FE 0D               	CP	CR		;en of the line?
    1514   00:E5FA  CA C1 E6            	JP	Z,RDBUF17
    1515   00:E5FD  FE 0A               	CP	LF
    1516   00:E5FF  CA C1 E6            	JP	Z,RDBUF17
    1517   00:E602  FE 08               	CP	BS		;how about a backspace?
    1518   00:E604  C2 16 E6            	JP	NZ,RDBUF3
    1519   00:E607  78                  	LD	A,B		;yes, but ignore at the beginning of the line.
    1520   00:E608  B7                  	OR	A
    1521   00:E609  CA EF E5            	JP	Z,RDBUF1
    1522   00:E60C  05                  	DEC	B		;ok, update counter.
    1523   00:E60D  3A 0C E7            	LD	A,(CURPOS)	;if we backspace to the start of the line,
    1524   00:E610  32 0A E7            	LD	(OUTFLAG),A	;treat as a cancel (control-x).
    1525   00:E613  C3 70 E6            	JP	RDBUF10
    1526   00:E616  FE 7F               RDBUF3:	CP	DEL		;user typed a rubout?
    1527   00:E618  C2 26 E6            	JP	NZ,RDBUF4
    1528   00:E61B  78                  	LD	A,B		;ignore at the start of the line.
    1529   00:E61C  B7                  	OR	A
    1530   00:E61D  CA EF E5            	JP	Z,RDBUF1
    1531   00:E620  7E                  	LD	A,(HL)		;ok, echo the prevoius character.
    1532   00:E621  05                  	DEC	B		;and reset pointers (counters).
    1533   00:E622  2B                  	DEC	HL
    1534   00:E623  C3 A9 E6            	JP	RDBUF15
    1535   00:E626  FE 05               RDBUF4:	CP	CNTRLE		;physical end of line?
    1536   00:E628  C2 37 E6            	JP	NZ,RDBUF5
    1537   00:E62B  C5                  	PUSH	BC		;yes, do it.
    1538   00:E62C  E5                  	PUSH	HL
    1539   00:E62D  CD C9 E5            	CALL	OUTCRLF
    1540   00:E630  AF                  	XOR	A		;and update starting position.
    1541   00:E631  32 0B E7            	LD	(STARTING),A
    1542   00:E634  C3 F1 E5            	JP	RDBUF2
    1543   00:E637  FE 10               RDBUF5:	CP	CNTRLP		;control-p?
    1544   00:E639  C2 48 E6            	JP	NZ,RDBUF6
    1545   00:E63C  E5                  	PUSH	HL		;yes, flip the print flag filp-flop byte.
    1546   00:E63D  21 0D E7            	LD	HL,PRTFLAG
    1547   00:E640  3E 01               	LD	A,1		;PRTFLAG=1-PRTFLAG
    1548   00:E642  96                  	SUB	(HL)
    1549   00:E643  77                  	LD	(HL),A
    1550   00:E644  E1                  	POP	HL
    1551   00:E645  C3 EF E5            	JP	RDBUF1
    1552   00:E648  FE 18               RDBUF6:	CP	CNTRLX		;control-x (cancel)?
    1553   00:E64A  C2 5F E6            	JP	NZ,RDBUF8
    1554   00:E64D  E1                  	POP	HL
    1555   00:E64E  3A 0B E7            RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here.
    1556   00:E651  21 0C E7            	LD	HL,CURPOS
    1557   00:E654  BE                  	CP	(HL)
    1558   00:E655  D2 E1 E5            	JP	NC,RDBUFF	;done yet?
    1559   00:E658  35                  	DEC	(HL)		;no, decrement pointer and output back up one space.
    1560   00:E659  CD A4 E5            	CALL	BACKUP
    1561   00:E65C  C3 4E E6            	JP	RDBUF7
    1562   00:E65F  FE 15               RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)?
    1563   00:E661  C2 6B E6            	JP	NZ,RDBUF9
    1564   00:E664  CD B1 E5            	CALL	NEWLINE		;start a new line.
    1565   00:E667  E1                  	POP	HL
    1566   00:E668  C3 E1 E5            	JP	RDBUFF
    1567   00:E66B  FE 12               RDBUF9:	CP	CNTRLR		;control-r?
    1568   00:E66D  C2 A6 E6            	JP	NZ,RDBUF14
    1569   00:E670  C5                  RDBUF10:PUSH	BC		;yes, start a new line and retype the old one.
    1570   00:E671  CD B1 E5            	CALL	NEWLINE
    1571   00:E674  C1                  	POP	BC
    1572   00:E675  E1                  	POP	HL
    1573   00:E676  E5                  	PUSH	HL
    1574   00:E677  C5                  	PUSH	BC
    1575   00:E678  78                  RDBUF11:LD	A,B		;done whole line yet?
    1576   00:E679  B7                  	OR	A
    1577   00:E67A  CA 8A E6            	JP	Z,RDBUF12
    1578   00:E67D  23                  	INC	HL		;nope, get next character.
    1579   00:E67E  4E                  	LD	C,(HL)
    1580   00:E67F  05                  	DEC	B		;count it.
    1581   00:E680  C5                  	PUSH	BC
    1582   00:E681  E5                  	PUSH	HL
    1583   00:E682  CD 7F E5            	CALL	SHOWIT		;and display it.
    1584   00:E685  E1                  	POP	HL
    1585   00:E686  C1                  	POP	BC
    1586   00:E687  C3 78 E6            	JP	RDBUF11
    1587   00:E68A  E5                  RDBUF12:PUSH	HL		;done with line. If we were displaying
    1588   00:E68B  3A 0A E7            	LD	A,(OUTFLAG)	;then update cursor position.
    1589   00:E68E  B7                  	OR	A
    1590   00:E68F  CA F1 E5            	JP	Z,RDBUF2
    1591   00:E692  21 0C E7            	LD	HL,CURPOS	;because this line is shorter, we must
    1592   00:E695  96                  	SUB	(HL)		;back up the cursor (not the screen however)
    1593   00:E696  32 0A E7            	LD	(OUTFLAG),A	;some number of positions.
    1594   00:E699  CD A4 E5            RDBUF13:CALL	BACKUP		;note that as long as (OUTFLAG) is non
    1595   00:E69C  21 0A E7            	LD	HL,OUTFLAG	;zero, the screen will not be changed.
    1596   00:E69F  35                  	DEC	(HL)
    1597   00:E6A0  C2 99 E6            	JP	NZ,RDBUF13
    1598   00:E6A3  C3 F1 E5            	JP	RDBUF2		;now just get the next character.
    1599   00:E6A6                      ;
    1600   00:E6A6                      ;   Just a normal character, put this in our buffer and echo.
    1601   00:E6A6                      ;
    1602   00:E6A6  23                  RDBUF14:INC	HL
    1603   00:E6A7  77                  	LD	(HL),A		;store character.
    1604   00:E6A8  04                  	INC	B		;and count it.
    1605   00:E6A9  C5                  RDBUF15:PUSH	BC
    1606   00:E6AA  E5                  	PUSH	HL
    1607   00:E6AB  4F                  	LD	C,A		;echo it now.
    1608   00:E6AC  CD 7F E5            	CALL	SHOWIT
    1609   00:E6AF  E1                  	POP	HL
    1610   00:E6B0  C1                  	POP	BC
    1611   00:E6B1  7E                  	LD	A,(HL)		;was it an abort request?
    1612   00:E6B2  FE 03               	CP	CNTRLC		;control-c abort?
    1613   00:E6B4  78                  	LD	A,B
    1614   00:E6B5  C2 BD E6            	JP	NZ,RDBUF16
    1615   00:E6B8  FE 01               	CP	1		;only if at start of line.
    1616   00:E6BA  CA 00 00            	JP	Z,0
    1617   00:E6BD  B9                  RDBUF16:CP	C		;nope, have we filled the buffer?
    1618   00:E6BE  DA EF E5            	JP	C,RDBUF1
    1619   00:E6C1  E1                  RDBUF17:POP	HL		;yes end the line and return.
    1620   00:E6C2  70                  	LD	(HL),B
    1621   00:E6C3  0E 0D               	LD	C,CR
    1622   00:E6C5  C3 48 E5            	JP	OUTCHAR		;output (cr) and return.
    1623   00:E6C8                      ;
    1624   00:E6C8                      ;   Function to get a character from the console device.
    1625   00:E6C8                      ;
    1626   00:E6C8  CD 06 E5            GETCON:	CALL	GETECHO		;get and echo.
    1627   00:E6CB  C3 01 E7            	JP	SETSTAT		;save status and return.
    1628   00:E6CE                      ;
    1629   00:E6CE                      ;   Function to get a character from the tape reader device.
    1630   00:E6CE                      ;
    1631   00:E6CE  CD 14 F2            GETRDR:	CALL	READER		;get a character from reader, set status and return.
    1632   00:E6D1  C3 01 E7            	JP	SETSTAT
    1633   00:E6D4                      ;
    1634   00:E6D4                      ;  Function to perform direct console i/o. If (C) contains (FF)
    1635   00:E6D4                      ; then this is an input request. If (C) contains (FE) then
    1636   00:E6D4                      ; this is a status request. Otherwise we are to output (C).
    1637   00:E6D4                      ;
    1638   00:E6D4  79                  DIRCIO:	LD	A,C		;test for (FF).
    1639   00:E6D5  3C                  	INC	A
    1640   00:E6D6  CA E0 E6            	JP	Z,DIRC1
    1641   00:E6D9  3C                  	INC	A		;test for (FE).
    1642   00:E6DA  CA 05 F2            	JP	Z,CONST
    1643   00:E6DD  C3 0B F2            	JP	CONOUT		;just output (C).
    1644   00:E6E0  CD 05 F2            DIRC1:	CALL	CONST		;this is an input request.
    1645   00:E6E3  B7                  	OR	A
    1646   00:E6E4  CA 90 F1            	JP	Z,GOBACK1	;not ready? Just return (directly).
    1647   00:E6E7  CD 08 F2            	CALL	CONIN		;yes, get character.
    1648   00:E6EA  C3 01 E7            	JP	SETSTAT		;set status and return.
    1649   00:E6ED                      ;
    1650   00:E6ED                      ;   Function to return the i/o byte.
    1651   00:E6ED                      ;
    1652   00:E6ED  3A 03 00            GETIOB:	LD	A,(IOBYTE)
    1653   00:E6F0  C3 01 E7            	JP	SETSTAT
    1654   00:E6F3                      ;
    1655   00:E6F3                      ;   Function to set the i/o byte.
    1656   00:E6F3                      ;
    1657   00:E6F3  21 03 00            SETIOB:	LD	HL,IOBYTE
    1658   00:E6F6  71                  	LD	(HL),C
    1659   00:E6F7  C9                  	RET	
    1660   00:E6F8                      ;
    1661   00:E6F8                      ;   Function to print the character string pointed to by (DE)
    1662   00:E6F8                      ; on the console device. The string ends with a '$'.
    1663   00:E6F8                      ;
    1664   00:E6F8  EB                  PRTSTR:	EX	DE,HL
    1665   00:E6F9  4D                  	LD	C,L
    1666   00:E6FA  44                  	LD	B,H		;now (BC) points to it.
    1667   00:E6FB  C3 D3 E5            	JP	PRTMESG
    1668   00:E6FE                      ;
    1669   00:E6FE                      ;   Function to interigate the console device.
    1670   00:E6FE                      ;
    1671   00:E6FE  CD 23 E5            GETCSTS:CALL	CKCONSOL
    1672   00:E701                      ;
    1673   00:E701                      ;   Get here to set the status and return to the cleanup
    1674   00:E701                      ; section. Then back to the user.
    1675   00:E701                      ;
    1676   00:E701  32 45 E7            SETSTAT:LD	(STATUS),A
    1677   00:E704  C9                  RTN:	RET	
    1678   00:E705                      ;
    1679   00:E705                      ;   Set the status to 1 (read or write error code).
    1680   00:E705                      ;
    1681   00:E705  3E 01               IOERR1:	LD	A,1
    1682   00:E707  C3 01 E7            	JP	SETSTAT
    1683   00:E70A                      ;
    1684   00:E70A  00                  OUTFLAG:DEFB	0		;output flag (non zero means no output).
    1685   00:E70B  02                  STARTING: DEFB	2		;starting position for cursor.
    1686   00:E70C  00                  CURPOS:	DEFB	0		;cursor position (0=start of line).
    1687   00:E70D  00                  PRTFLAG:DEFB	0		;printer flag (control-p toggle). List if non zero.
    1688   00:E70E  00                  CHARBUF:DEFB	0		;single input character buffer.
    1689   00:E70F                      ;
    1690   00:E70F                      ;   Stack area for BDOS calls.
    1691   00:E70F                      ;
    1692   00:E70F  00 00               USRSTACK: DEFW	0		;save users stack pointer here.
    1693   00:E711                      ;
    1694   00:E711                      	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    1694   00:E711  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
    1694   00:E721  00 00 00 00 00 00 00 00 
    1695   00:E729                      	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    1695   00:E729  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
    1695   00:E739  00 00 00 00 00 00 00 00 
    1696   00:E741  (00:E741)           STKAREA EQU	$		;end of stack area.
    1697   00:E741                      ;
    1698   00:E741  00                  USERNO:	DEFB	0		;current user number.
    1699   00:E742  00                  ACTIVE:	DEFB	0		;currently active drive.
    1700   00:E743  00 00               PARAMS:	DEFW	0		;save (DE) parameters here on entry.
    1701   00:E745  00 00               STATUS:	DEFW	0		;status returned from bdos function.
    1702   00:E747                      ;
    1703   00:E747                      ;   Select error occured, jump to error routine.
    1704   00:E747                      ;
    1705   00:E747  21 0B E4            SLCTERR:LD	HL,BADSLCT
    1706   00:E74A                      ;
    1707   00:E74A                      ;   Jump to (HL) indirectly.
    1708   00:E74A                      ;
    1709   00:E74A  5E                  JUMPHL:	LD	E,(HL)
    1710   00:E74B  23                  	INC	HL
    1711   00:E74C  56                  	LD	D,(HL)		;now (DE) contain the desired address.
    1712   00:E74D  EB                  	EX	DE,HL
    1713   00:E74E  E9                  	JP	(HL)
    1714   00:E74F                      ;
    1715   00:E74F                      ;   Block move. (DE) to (HL), (C) bytes total.
    1716   00:E74F                      ;
    1717   00:E74F  0C                  DE2HL:	INC	C		;is count down to zero?
    1718   00:E750  0D                  DE2HL1:	DEC	C
    1719   00:E751  C8                  	RET	Z		;yes, we are done.
    1720   00:E752  1A                  	LD	A,(DE)		;no, move one more byte.
    1721   00:E753  77                  	LD	(HL),A
    1722   00:E754  13                  	INC	DE
    1723   00:E755  23                  	INC	HL
    1724   00:E756  C3 50 E7            	JP	DE2HL1		;and repeat.
    1725   00:E759                      ;
    1726   00:E759                      ;   Select the desired drive.
    1727   00:E759                      ;
    1728   00:E759  3A 42 E7            SELECT:	LD	A,(ACTIVE)	;get active disk.
    1729   00:E75C  4F                  	LD	C,A
    1730   00:E75D  CD 1A F2            	CALL	SELDSK		;select it.
    1731   00:E760  7C                  	LD	A,H		;valid drive?
    1732   00:E761  B5                  	OR	L		;valid drive?
    1733   00:E762  C8                  	RET	Z		;return if not.
    1734   00:E763                      ;
    1735   00:E763                      ;   Here, the BIOS returned the address of the parameter block
    1736   00:E763                      ; in (HL). We will extract the necessary pointers and save them.
    1737   00:E763                      ;
    1738   00:E763  5E                  	LD	E,(HL)		;yes, get address of translation table into (DE).
    1739   00:E764  23                  	INC	HL
    1740   00:E765  56                  	LD	D,(HL)
    1741   00:E766  23                  	INC	HL
    1742   00:E767  22 B2 F1            	LD	(SCRATCH1),HL	;save pointers to scratch areas.
    1743   00:E76A  23                  	INC	HL
    1744   00:E76B  23                  	INC	HL
    1745   00:E76C  22 B4 F1            	LD	(SCRATCH2),HL	;ditto.
    1746   00:E76F  23                  	INC	HL
    1747   00:E770  23                  	INC	HL
    1748   00:E771  22 B6 F1            	LD	(SCRATCH3),HL	;ditto.
    1749   00:E774  23                  	INC	HL
    1750   00:E775  23                  	INC	HL
    1751   00:E776  EB                  	EX	DE,HL		;now save the translation table address.
    1752   00:E777  22 CF F1            	LD	(XLATE),HL
    1753   00:E77A  21 B8 F1            	LD	HL,DIRBUF	;put the next 8 bytes here.
    1754   00:E77D  0E 08               	LD	C,8		;they consist of the directory buffer
    1755   00:E77F  CD 4F E7            	CALL	DE2HL		;pointer, parameter block pointer,
    1756   00:E782  2A BA F1            	LD	HL,(DISKPB)	;check and allocation vectors.
    1757   00:E785  EB                  	EX	DE,HL
    1758   00:E786  21 C0 F1            	LD	HL,SECTORS	;move parameter block into our ram.
    1759   00:E789  0E 0F               	LD	C,15		;it is 15 bytes long.
    1760   00:E78B  CD 4F E7            	CALL	DE2HL
    1761   00:E78E  2A C5 F1            	LD	HL,(DSKSIZE)	;check disk size.
    1762   00:E791  7C                  	LD	A,H		;more than 256 blocks on this?
    1763   00:E792  21 DC F1            	LD	HL,BIGDISK
    1764   00:E795  36 FF               	LD	(HL),0FFH	;set to samll.
    1765   00:E797  B7                  	OR	A
    1766   00:E798  CA 9D E7            	JP	Z,SELECT1
    1767   00:E79B  36 00               	LD	(HL),0		;wrong, set to large.
    1768   00:E79D  3E FF               SELECT1:LD	A,0FFH		;clear the zero flag.
    1769   00:E79F  B7                  	OR	A
    1770   00:E7A0  C9                  	RET	
    1771   00:E7A1                      ;
    1772   00:E7A1                      ;   Routine to home the disk track head and clear pointers.
    1773   00:E7A1                      ;
    1774   00:E7A1  CD 17 F2            HOMEDRV:CALL	HOME		;home the head.
    1775   00:E7A4  AF                  	XOR	A
    1776   00:E7A5  2A B4 F1            	LD	HL,(SCRATCH2)	;set our track pointer also.
    1777   00:E7A8  77                  	LD	(HL),A
    1778   00:E7A9  23                  	INC	HL
    1779   00:E7AA  77                  	LD	(HL),A
    1780   00:E7AB  2A B6 F1            	LD	HL,(SCRATCH3)	;and our sector pointer.
    1781   00:E7AE  77                  	LD	(HL),A
    1782   00:E7AF  23                  	INC	HL
    1783   00:E7B0  77                  	LD	(HL),A
    1784   00:E7B1  C9                  	RET	
    1785   00:E7B2                      ;
    1786   00:E7B2                      ;   Do the actual disk read and check the error return status.
    1787   00:E7B2                      ;
    1788   00:E7B2  CD 26 F2            DOREAD:	CALL	READ
    1789   00:E7B5  C3 BB E7            	JP	IORET
    1790   00:E7B8                      ;
    1791   00:E7B8                      ;   Do the actual disk write and handle any bios error.
    1792   00:E7B8                      ;
    1793   00:E7B8  CD 29 F2            DOWRITE:CALL	WRITE
    1794   00:E7BB  B7                  IORET:	OR	A
    1795   00:E7BC  C8                  	RET	Z		;return unless an error occured.
    1796   00:E7BD  21 09 E4            	LD	HL,BADSCTR	;bad read/write on this sector.
    1797   00:E7C0  C3 4A E7            	JP	JUMPHL
    1798   00:E7C3                      ;
    1799   00:E7C3                      ;   Routine to select the track and sector that the desired
    1800   00:E7C3                      ; block number falls in.
    1801   00:E7C3                      ;
    1802   00:E7C3  2A E9 F1            TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file
    1803   00:E7C6  0E 02               	LD	C,2		;in directory and compute sector #.
    1804   00:E7C8  CD EA E8            	CALL	SHIFTR		;sector #=file-position/4.
    1805   00:E7CB  22 E4 F1            	LD	(BLKNMBR),HL	;save this as the block number of interest.
    1806   00:E7CE  22 EB F1            	LD	(CKSUMTBL),HL	;what's it doing here too?
    1807   00:E7D1                      ;
    1808   00:E7D1                      ;   if the sector number has already been set (BLKNMBR), enter
    1809   00:E7D1                      ; at this point.
    1810   00:E7D1                      ;
    1811   00:E7D1  21 E4 F1            TRKSEC1:LD	HL,BLKNMBR
    1812   00:E7D4  4E                  	LD	C,(HL)		;move sector number into (BC).
    1813   00:E7D5  23                  	INC	HL
    1814   00:E7D6  46                  	LD	B,(HL)
    1815   00:E7D7  2A B6 F1            	LD	HL,(SCRATCH3)	;get current sector number and
    1816   00:E7DA  5E                  	LD	E,(HL)		;move this into (DE).
    1817   00:E7DB  23                  	INC	HL
    1818   00:E7DC  56                  	LD	D,(HL)
    1819   00:E7DD  2A B4 F1            	LD	HL,(SCRATCH2)	;get current track number.
    1820   00:E7E0  7E                  	LD	A,(HL)		;and this into (HL).
    1821   00:E7E1  23                  	INC	HL
    1822   00:E7E2  66                  	LD	H,(HL)
    1823   00:E7E3  6F                  	LD	L,A
    1824   00:E7E4  79                  TRKSEC2:LD	A,C		;is desired sector before current one?
    1825   00:E7E5  93                  	SUB	E
    1826   00:E7E6  78                  	LD	A,B
    1827   00:E7E7  9A                  	SBC	A,D
    1828   00:E7E8  D2 FA E7            	JP	NC,TRKSEC3
    1829   00:E7EB  E5                  	PUSH	HL		;yes, decrement sectors by one track.
    1830   00:E7EC  2A C0 F1            	LD	HL,(SECTORS)	;get sectors per track.
    1831   00:E7EF  7B                  	LD	A,E
    1832   00:E7F0  95                  	SUB	L
    1833   00:E7F1  5F                  	LD	E,A
    1834   00:E7F2  7A                  	LD	A,D
    1835   00:E7F3  9C                  	SBC	A,H
    1836   00:E7F4  57                  	LD	D,A		;now we have backed up one full track.
    1837   00:E7F5  E1                  	POP	HL
    1838   00:E7F6  2B                  	DEC	HL		;adjust track counter.
    1839   00:E7F7  C3 E4 E7            	JP	TRKSEC2
    1840   00:E7FA  E5                  TRKSEC3:PUSH	HL		;desired sector is after current one.
    1841   00:E7FB  2A C0 F1            	LD	HL,(SECTORS)	;get sectors per track.
    1842   00:E7FE  19                  	ADD	HL,DE		;bump sector pointer to next track.
    1843   00:E7FF  DA 0F E8            	JP	C,TRKSEC4
    1844   00:E802  79                  	LD	A,C		;is desired sector now before current one?
    1845   00:E803  95                  	SUB	L
    1846   00:E804  78                  	LD	A,B
    1847   00:E805  9C                  	SBC	A,H
    1848   00:E806  DA 0F E8            	JP	C,TRKSEC4
    1849   00:E809  EB                  	EX	DE,HL		;not yes, increment track counter
    1850   00:E80A  E1                  	POP	HL		;and continue until it is.
    1851   00:E80B  23                  	INC	HL
    1852   00:E80C  C3 FA E7            	JP	TRKSEC3
    1853   00:E80F                      ;
    1854   00:E80F                      ;   here we have determined the track number that contains the
    1855   00:E80F                      ; desired sector.
    1856   00:E80F                      ;
    1857   00:E80F  E1                  TRKSEC4:POP	HL		;get track number (HL).
    1858   00:E810  C5                  	PUSH	BC
    1859   00:E811  D5                  	PUSH	DE
    1860   00:E812  E5                  	PUSH	HL
    1861   00:E813  EB                  	EX	DE,HL
    1862   00:E814  2A CD F1            	LD	HL,(OFFSET)	;adjust for first track offset.
    1863   00:E817  19                  	ADD	HL,DE
    1864   00:E818  44                  	LD	B,H
    1865   00:E819  4D                  	LD	C,L
    1866   00:E81A  CD 1D F2            	CALL	SETTRK		;select this track.
    1867   00:E81D  D1                  	POP	DE		;reset current track pointer.
    1868   00:E81E  2A B4 F1            	LD	HL,(SCRATCH2)
    1869   00:E821  73                  	LD	(HL),E
    1870   00:E822  23                  	INC	HL
    1871   00:E823  72                  	LD	(HL),D
    1872   00:E824  D1                  	POP	DE
    1873   00:E825  2A B6 F1            	LD	HL,(SCRATCH3)	;reset the first sector on this track.
    1874   00:E828  73                  	LD	(HL),E
    1875   00:E829  23                  	INC	HL
    1876   00:E82A  72                  	LD	(HL),D
    1877   00:E82B  C1                  	POP	BC
    1878   00:E82C  79                  	LD	A,C		;now subtract the desired one.
    1879   00:E82D  93                  	SUB	E		;to make it relative (1-# sectors/track).
    1880   00:E82E  4F                  	LD	C,A
    1881   00:E82F  78                  	LD	A,B
    1882   00:E830  9A                  	SBC	A,D
    1883   00:E831  47                  	LD	B,A
    1884   00:E832  2A CF F1            	LD	HL,(XLATE)	;translate this sector according to this table.
    1885   00:E835  EB                  	EX	DE,HL
    1886   00:E836  CD 2F F2            	CALL	SECTRN		;let the bios translate it.
    1887   00:E839  4D                  	LD	C,L
    1888   00:E83A  44                  	LD	B,H
    1889   00:E83B  C3 20 F2            	JP	SETSEC		;and select it.
    1890   00:E83E                      ;
    1891   00:E83E                      ;   Compute block number from record number (SAVNREC) and
    1892   00:E83E                      ; extent number (SAVEXT).
    1893   00:E83E                      ;
    1894   00:E83E  21 C2 F1            GETBLOCK: LD	HL,BLKSHFT	;get logical to physical conversion.
    1895   00:E841  4E                  	LD	C,(HL)		;note that this is base 2 log of ratio.
    1896   00:E842  3A E2 F1            	LD	A,(SAVNREC)	;get record number.
    1897   00:E845  B7                  GETBLK1:OR	A		;compute (A)=(A)/2^BLKSHFT.
    1898   00:E846  1F                  	RRA	
    1899   00:E847  0D                  	DEC	C
    1900   00:E848  C2 45 E8            	JP	NZ,GETBLK1
    1901   00:E84B  47                  	LD	B,A		;save result in (B).
    1902   00:E84C  3E 08               	LD	A,8
    1903   00:E84E  96                  	SUB	(HL)
    1904   00:E84F  4F                  	LD	C,A		;compute (C)=8-BLKSHFT.
    1905   00:E850  3A E1 F1            	LD	A,(SAVEXT)
    1906   00:E853  0D                  GETBLK2:DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT).
    1907   00:E854  CA 5C E8            	JP	Z,GETBLK3
    1908   00:E857  B7                  	OR	A
    1909   00:E858  17                  	RLA	
    1910   00:E859  C3 53 E8            	JP	GETBLK2
    1911   00:E85C  80                  GETBLK3:ADD	A,B
    1912   00:E85D  C9                  	RET	
    1913   00:E85E                      ;
    1914   00:E85E                      ;   Routine to extract the (BC) block byte from the fcb pointed
    1915   00:E85E                      ; to by (PARAMS). If this is a big-disk, then these are 16 bit
    1916   00:E85E                      ; block numbers, else they are 8 bit numbers.
    1917   00:E85E                      ; Number is returned in (HL).
    1918   00:E85E                      ;
    1919   00:E85E  2A 43 E7            EXTBLK:	LD	HL,(PARAMS)	;get fcb address.
    1920   00:E861  11 10 00            	LD	DE,16		;block numbers start 16 bytes into fcb.
    1921   00:E864  19                  	ADD	HL,DE
    1922   00:E865  09                  	ADD	HL,BC
    1923   00:E866  3A DC F1            	LD	A,(BIGDISK)	;are we using a big-disk?
    1924   00:E869  B7                  	OR	A
    1925   00:E86A  CA 71 E8            	JP	Z,EXTBLK1
    1926   00:E86D  6E                  	LD	L,(HL)		;no, extract an 8 bit number from the fcb.
    1927   00:E86E  26 00               	LD	H,0
    1928   00:E870  C9                  	RET	
    1929   00:E871  09                  EXTBLK1:ADD	HL,BC		;yes, extract a 16 bit number.
    1930   00:E872  5E                  	LD	E,(HL)
    1931   00:E873  23                  	INC	HL
    1932   00:E874  56                  	LD	D,(HL)
    1933   00:E875  EB                  	EX	DE,HL		;return in (HL).
    1934   00:E876  C9                  	RET	
    1935   00:E877                      ;
    1936   00:E877                      ;   Compute block number.
    1937   00:E877                      ;
    1938   00:E877  CD 3E E8            COMBLK:	CALL	GETBLOCK
    1939   00:E87A  4F                  	LD	C,A
    1940   00:E87B  06 00               	LD	B,0
    1941   00:E87D  CD 5E E8            	CALL	EXTBLK
    1942   00:E880  22 E4 F1            	LD	(BLKNMBR),HL
    1943   00:E883  C9                  	RET	
    1944   00:E884                      ;
    1945   00:E884                      ;   Check for a zero block number (unused).
    1946   00:E884                      ;
    1947   00:E884  2A E4 F1            CHKBLK:	LD	HL,(BLKNMBR)
    1948   00:E887  7D                  	LD	A,L		;is it zero?
    1949   00:E888  B4                  	OR	H
    1950   00:E889  C9                  	RET	
    1951   00:E88A                      ;
    1952   00:E88A                      ;   Adjust physical block (BLKNMBR) and convert to logical
    1953   00:E88A                      ; sector (LOGSECT). This is the starting sector of this block.
    1954   00:E88A                      ; The actual sector of interest is then added to this and the
    1955   00:E88A                      ; resulting sector number is stored back in (BLKNMBR). This
    1956   00:E88A                      ; will still have to be adjusted for the track number.
    1957   00:E88A                      ;
    1958   00:E88A  3A C2 F1            LOGICAL:LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
    1959   00:E88D  2A E4 F1            	LD	HL,(BLKNMBR)	;get physical sector desired.
    1960   00:E890  29                  LOGICL1:ADD	HL,HL		;compute logical sector number.
    1961   00:E891  3D                  	DEC	A		;note logical sectors are 128 bytes long.
    1962   00:E892  C2 90 E8            	JP	NZ,LOGICL1
    1963   00:E895  22 E6 F1            	LD	(LOGSECT),HL	;save logical sector.
    1964   00:E898  3A C3 F1            	LD	A,(BLKMASK)	;get block mask.
    1965   00:E89B  4F                  	LD	C,A
    1966   00:E89C  3A E2 F1            	LD	A,(SAVNREC)	;get next sector to access.
    1967   00:E89F  A1                  	AND	C		;extract the relative position within physical block.
    1968   00:E8A0  B5                  	OR	L		;and add it too logical sector.
    1969   00:E8A1  6F                  	LD	L,A
    1970   00:E8A2  22 E4 F1            	LD	(BLKNMBR),HL	;and store.
    1971   00:E8A5  C9                  	RET	
    1972   00:E8A6                      ;
    1973   00:E8A6                      ;   Set (HL) to point to extent byte in fcb.
    1974   00:E8A6                      ;
    1975   00:E8A6  2A 43 E7            SETEXT:	LD	HL,(PARAMS)
    1976   00:E8A9  11 0C 00            	LD	DE,12		;it is the twelth byte.
    1977   00:E8AC  19                  	ADD	HL,DE
    1978   00:E8AD  C9                  	RET	
    1979   00:E8AE                      ;
    1980   00:E8AE                      ;   Set (HL) to point to record count byte in fcb and (DE) to
    1981   00:E8AE                      ; next record number byte.
    1982   00:E8AE                      ;
    1983   00:E8AE  2A 43 E7            SETHLDE:LD	HL,(PARAMS)
    1984   00:E8B1  11 0F 00            	LD	DE,15		;record count byte (#15).
    1985   00:E8B4  19                  	ADD	HL,DE
    1986   00:E8B5  EB                  	EX	DE,HL
    1987   00:E8B6  21 11 00            	LD	HL,17		;next record number (#32).
    1988   00:E8B9  19                  	ADD	HL,DE
    1989   00:E8BA  C9                  	RET	
    1990   00:E8BB                      ;
    1991   00:E8BB                      ;   Save current file data from fcb.
    1992   00:E8BB                      ;
    1993   00:E8BB  CD AE E8            STRDATA:CALL	SETHLDE
    1994   00:E8BE  7E                  	LD	A,(HL)		;get and store record count byte.
    1995   00:E8BF  32 E2 F1            	LD	(SAVNREC),A
    1996   00:E8C2  EB                  	EX	DE,HL
    1997   00:E8C3  7E                  	LD	A,(HL)		;get and store next record number byte.
    1998   00:E8C4  32 E0 F1            	LD	(SAVNXT),A
    1999   00:E8C7  CD A6 E8            	CALL	SETEXT		;point to extent byte.
    2000   00:E8CA  3A C4 F1            	LD	A,(EXTMASK)	;get extent mask.
    2001   00:E8CD  A6                  	AND	(HL)
    2002   00:E8CE  32 E1 F1            	LD	(SAVEXT),A	;and save extent here.
    2003   00:E8D1  C9                  	RET	
    2004   00:E8D2                      ;
    2005   00:E8D2                      ;   Set the next record to access. If (MODE) is set to 2, then
    2006   00:E8D2                      ; the last record byte (SAVNREC) has the correct number to access.
    2007   00:E8D2                      ; For sequential access, (MODE) will be equal to 1.
    2008   00:E8D2                      ;
    2009   00:E8D2  CD AE E8            SETNREC:CALL	SETHLDE
    2010   00:E8D5  3A D4 F1            	LD	A,(MODE)	;get sequential flag (=1).
    2011   00:E8D8  FE 02               	CP	2		;a 2 indicates that no adder is needed.
    2012   00:E8DA  C2 DE E8            	JP	NZ,STNREC1
    2013   00:E8DD  AF                  	XOR	A		;clear adder (random access?).
    2014   00:E8DE  4F                  STNREC1:LD	C,A
    2015   00:E8DF  3A E2 F1            	LD	A,(SAVNREC)	;get last record number.
    2016   00:E8E2  81                  	ADD	A,C		;increment record count.
    2017   00:E8E3  77                  	LD	(HL),A		;and set fcb's next record byte.
    2018   00:E8E4  EB                  	EX	DE,HL
    2019   00:E8E5  3A E0 F1            	LD	A,(SAVNXT)	;get next record byte from storage.
    2020   00:E8E8  77                  	LD	(HL),A		;and put this into fcb as number of records used.
    2021   00:E8E9  C9                  	RET	
    2022   00:E8EA                      ;
    2023   00:E8EA                      ;   Shift (HL) right (C) bits.
    2024   00:E8EA                      ;
    2025   00:E8EA  0C                  SHIFTR:	INC	C
    2026   00:E8EB  0D                  SHIFTR1:DEC	C
    2027   00:E8EC  C8                  	RET	Z
    2028   00:E8ED  7C                  	LD	A,H
    2029   00:E8EE  B7                  	OR	A
    2030   00:E8EF  1F                  	RRA	
    2031   00:E8F0  67                  	LD	H,A
    2032   00:E8F1  7D                  	LD	A,L
    2033   00:E8F2  1F                  	RRA	
    2034   00:E8F3  6F                  	LD	L,A
    2035   00:E8F4  C3 EB E8            	JP	SHIFTR1
    2036   00:E8F7                      ;
    2037   00:E8F7                      ;   Compute the check-sum for the directory buffer. Return
    2038   00:E8F7                      ; integer sum in (A).
    2039   00:E8F7                      ;
    2040   00:E8F7  0E 80               CHECKSUM: LD	C,128		;length of buffer.
    2041   00:E8F9  2A B8 F1            	LD	HL,(DIRBUF)	;get its location.
    2042   00:E8FC  AF                  	XOR	A		;clear summation byte.
    2043   00:E8FD  46                  CHKSUM1:LD B,(HL)
    2044   00:E8FE  80                  	ADD	A,B		;and compute sum ignoring carries.
    2045   00:E8FF  23                  	INC	HL
    2046   00:E900  0D                  	DEC	C
    2047   00:E901  C2 FD E8            	JP	NZ,CHKSUM1
    2048   00:E904  C9                  	RET	
    2049   00:E905                      ;
    2050   00:E905                      ;   Shift (HL) left (C) bits.
    2051   00:E905                      ;
    2052   00:E905  0C                  SHIFTL:	INC	C
    2053   00:E906  0D                  SHIFTL1:DEC	C
    2054   00:E907  C8                  	RET	Z
    2055   00:E908  29                  	ADD	HL,HL		;shift left 1 bit.
    2056   00:E909  C3 06 E9            	JP	SHIFTL1
    2057   00:E90C                      ;
    2058   00:E90C                      ;   Routine to set a bit in a 16 bit value contained in (BC).
    2059   00:E90C                      ; The bit set depends on the current drive selection.
    2060   00:E90C                      ;
    2061   00:E90C  C5                  SETBIT:	PUSH	BC		;save 16 bit word.
    2062   00:E90D  3A 42 E7            	LD	A,(ACTIVE)	;get active drive.
    2063   00:E910  4F                  	LD	C,A
    2064   00:E911  21 01 00            	LD	HL,1
    2065   00:E914  CD 05 E9            	CALL	SHIFTL		;shift bit 0 into place.
    2066   00:E917  C1                  	POP	BC		;now 'or' this with the original word.
    2067   00:E918  79                  	LD	A,C
    2068   00:E919  B5                  	OR	L
    2069   00:E91A  6F                  	LD	L,A		;low byte done, do high byte.
    2070   00:E91B  78                  	LD	A,B
    2071   00:E91C  B4                  	OR	H
    2072   00:E91D  67                  	LD	H,A
    2073   00:E91E  C9                  	RET	
    2074   00:E91F                      ;
    2075   00:E91F                      ;   Extract the write protect status bit for the current drive.
    2076   00:E91F                      ; The result is returned in (A), bit 0.
    2077   00:E91F                      ;
    2078   00:E91F  2A AC F1            GETWPRT:LD	HL,(WRTPRT)	;get status bytes.
    2079   00:E922  3A 42 E7            	LD	A,(ACTIVE)	;which drive is current?
    2080   00:E925  4F                  	LD	C,A
    2081   00:E926  CD EA E8            	CALL	SHIFTR		;shift status such that bit 0 is the
    2082   00:E929  7D                  	LD	A,L		;one of interest for this drive.
    2083   00:E92A  E6 01               	AND	01H		;and isolate it.
    2084   00:E92C  C9                  	RET	
    2085   00:E92D                      ;
    2086   00:E92D                      ;   Function to write protect the current disk.
    2087   00:E92D                      ;
    2088   00:E92D  21 AC F1            WRTPRTD:LD	HL,WRTPRT	;point to status word.
    2089   00:E930  4E                  	LD	C,(HL)		;set (BC) equal to the status.
    2090   00:E931  23                  	INC	HL
    2091   00:E932  46                  	LD	B,(HL)
    2092   00:E933  CD 0C E9            	CALL	SETBIT		;and set this bit according to current drive.
    2093   00:E936  22 AC F1            	LD	(WRTPRT),HL	;then save.
    2094   00:E939  2A C7 F1            	LD	HL,(DIRSIZE)	;now save directory size limit.
    2095   00:E93C  23                  	INC	HL		;remember the last one.
    2096   00:E93D  EB                  	EX	DE,HL
    2097   00:E93E  2A B2 F1            	LD	HL,(SCRATCH1)	;and store it here.
    2098   00:E941  73                  	LD	(HL),E		;put low byte.
    2099   00:E942  23                  	INC	HL
    2100   00:E943  72                  	LD	(HL),D		;then high byte.
    2101   00:E944  C9                  	RET	
    2102   00:E945                      ;
    2103   00:E945                      ;   Check for a read only file.
    2104   00:E945                      ;
    2105   00:E945  CD 5F E9            CHKROFL:CALL	FCB2HL		;set (HL) to file entry in directory buffer.
    2106   00:E948  11 09 00            CKROF1:	LD	DE,9		;look at bit 7 of the ninth byte.
    2107   00:E94B  19                  	ADD	HL,DE
    2108   00:E94C  7E                  	LD	A,(HL)
    2109   00:E94D  17                  	RLA	
    2110   00:E94E  D0                  	RET	NC		;return if ok.
    2111   00:E94F  21 0F E4            	LD	HL,ROFILE	;else, print error message and terminate.
    2112   00:E952  C3 4A E7            	JP	JUMPHL
    2113   00:E955                      ;
    2114   00:E955                      ;   Check the write protect status of the active disk.
    2115   00:E955                      ;
    2116   00:E955  CD 1F E9            CHKWPRT:CALL	GETWPRT
    2117   00:E958  C8                  	RET	Z		;return if ok.
    2118   00:E959  21 0D E4            	LD	HL,RODISK	;else print message and terminate.
    2119   00:E95C  C3 4A E7            	JP	JUMPHL
    2120   00:E95F                      ;
    2121   00:E95F                      ;   Routine to set (HL) pointing to the proper entry in the
    2122   00:E95F                      ; directory buffer.
    2123   00:E95F                      ;
    2124   00:E95F  2A B8 F1            FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer.
    2125   00:E962  3A E8 F1            	LD	A,(FCBPOS)	;relative position of file.
    2126   00:E965                      ;
    2127   00:E965                      ;   Routine to add (A) to (HL).
    2128   00:E965                      ;
    2129   00:E965  85                  ADDA2HL:ADD	A,L
    2130   00:E966  6F                  	LD	L,A
    2131   00:E967  D0                  	RET	NC
    2132   00:E968  24                  	INC	H		;take care of any carry.
    2133   00:E969  C9                  	RET	
    2134   00:E96A                      ;
    2135   00:E96A                      ;   Routine to get the 's2' byte from the fcb supplied in
    2136   00:E96A                      ; the initial parameter specification.
    2137   00:E96A                      ;
    2138   00:E96A  2A 43 E7            GETS2:	LD	HL,(PARAMS)	;get address of fcb.
    2139   00:E96D  11 0E 00            	LD	DE,14		;relative position of 's2'.
    2140   00:E970  19                  	ADD	HL,DE
    2141   00:E971  7E                  	LD	A,(HL)		;extract this byte.
    2142   00:E972  C9                  	RET	
    2143   00:E973                      ;
    2144   00:E973                      ;   Clear the 's2' byte in the fcb.
    2145   00:E973                      ;
    2146   00:E973  CD 6A E9            CLEARS2:CALL	GETS2		;this sets (HL) pointing to it.
    2147   00:E976  36 00               	LD	(HL),0		;now clear it.
    2148   00:E978  C9                  	RET	
    2149   00:E979                      ;
    2150   00:E979                      ;   Set bit 7 in the 's2' byte of the fcb.
    2151   00:E979                      ;
    2152   00:E979  CD 6A E9            SETS2B7:CALL	GETS2		;get the byte.
    2153   00:E97C  F6 80               	OR	80H		;and set bit 7.
    2154   00:E97E  77                  	LD	(HL),A		;then store.
    2155   00:E97F  C9                  	RET	
    2156   00:E980                      ;
    2157   00:E980                      ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
    2158   00:E980                      ; the difference. This checks to see if there are more file
    2159   00:E980                      ; names in the directory. We are at (FILEPOS) and there are
    2160   00:E980                      ; (SCRATCH1) of them to check.
    2161   00:E980                      ;
    2162   00:E980  2A E9 F1            MOREFLS:LD	HL,(FILEPOS)	;we are here.
    2163   00:E983  EB                  	EX	DE,HL
    2164   00:E984  2A B2 F1            	LD	HL,(SCRATCH1)	;and don't go past here.
    2165   00:E987  7B                  	LD	A,E		;compute difference but don't keep.
    2166   00:E988  96                  	SUB	(HL)
    2167   00:E989  23                  	INC	HL
    2168   00:E98A  7A                  	LD	A,D
    2169   00:E98B  9F                  	SBC	A,A		;set carry if no more names.
    2170   00:E98C  C9                  	RET	
    2171   00:E98D                      ;
    2172   00:E98D                      ;   Call this routine to prevent (SCRATCH1) from being greater
    2173   00:E98D                      ; than (FILEPOS).
    2174   00:E98D                      ;
    2175   00:E98D  CD 80 E9            CHKNMBR:CALL	MOREFLS		;SCRATCH1 too big?
    2176   00:E990  D8                  	RET	C
    2177   00:E991  13                  	INC	DE		;yes, reset it to (FILEPOS).
    2178   00:E992  72                  	LD	(HL),D
    2179   00:E993  2B                  	DEC	HL
    2180   00:E994  73                  	LD	(HL),E
    2181   00:E995  C9                  	RET	
    2182   00:E996                      ;
    2183   00:E996                      ;   Compute (HL)=(DE)-(HL)
    2184   00:E996                      ;
    2185   00:E996  7B                  SUBHL:	LD	A,E		;compute difference.
    2186   00:E997  95                  	SUB	L
    2187   00:E998  6F                  	LD	L,A		;store low byte.
    2188   00:E999  7A                  	LD	A,D
    2189   00:E99A  9C                  	SBC	A,H
    2190   00:E99B  67                  	LD	H,A		;and then high byte.
    2191   00:E99C  C9                  	RET	
    2192   00:E99D                      ;
    2193   00:E99D                      ;   Set the directory checksum byte.
    2194   00:E99D                      ;
    2195   00:E99D  0E FF               SETDIR:	LD	C,0FFH
    2196   00:E99F                      ;
    2197   00:E99F                      ;   Routine to set or compare the directory checksum byte. If
    2198   00:E99F                      ; (C)=0ffh, then this will set the checksum byte. Else the byte
    2199   00:E99F                      ; will be checked. If the check fails (the disk has been changed),
    2200   00:E99F                      ; then this disk will be write protected.
    2201   00:E99F                      ;
    2202   00:E99F  2A EB F1            CHECKDIR: LD	HL,(CKSUMTBL)
    2203   00:E9A2  EB                  	EX	DE,HL
    2204   00:E9A3  2A CB F1            	LD	HL,(ALLOC1)
    2205   00:E9A6  CD 96 E9            	CALL	SUBHL
    2206   00:E9A9  D0                  	RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return.
    2207   00:E9AA  C5                  	PUSH	BC
    2208   00:E9AB  CD F7 E8            	CALL	CHECKSUM	;else compute checksum.
    2209   00:E9AE  2A BC F1            	LD	HL,(CHKVECT)	;get address of checksum table.
    2210   00:E9B1  EB                  	EX	DE,HL
    2211   00:E9B2  2A EB F1            	LD	HL,(CKSUMTBL)
    2212   00:E9B5  19                  	ADD	HL,DE		;set (HL) to point to byte for this drive.
    2213   00:E9B6  C1                  	POP	BC
    2214   00:E9B7  0C                  	INC	C		;set or check ?
    2215   00:E9B8  CA C5 E9            	JP	Z,CHKDIR1
    2216   00:E9BB  BE                  	CP	(HL)		;check them.
    2217   00:E9BC  C8                  	RET	Z		;return if they are the same.
    2218   00:E9BD  CD 80 E9            	CALL	MOREFLS		;not the same, do we care?
    2219   00:E9C0  D0                  	RET	NC
    2220   00:E9C1  CD 2D E9            	CALL	WRTPRTD		;yes, mark this as write protected.
    2221   00:E9C4  C9                  	RET	
    2222   00:E9C5  77                  CHKDIR1:LD	(HL),A		;just set the byte.
    2223   00:E9C6  C9                  	RET	
    2224   00:E9C7                      ;
    2225   00:E9C7                      ;   Do a write to the directory of the current disk.
    2226   00:E9C7                      ;
    2227   00:E9C7  CD 9D E9            DIRWRITE: CALL	SETDIR		;set checksum byte.
    2228   00:E9CA  CD E1 E9            	CALL	DIRDMA		;set directory dma address.
    2229   00:E9CD  0E 01               	LD	C,1		;tell the bios to actually write.
    2230   00:E9CF  CD B8 E7            	CALL	DOWRITE		;then do the write.
    2231   00:E9D2  C3 DB E9            	JP	DEFDMA
    2232   00:E9D5                      ;
    2233   00:E9D5                      ;   Read from the directory.
    2234   00:E9D5                      ;
    2235   00:E9D5  CD E1 E9            DIRREAD:CALL	DIRDMA		;set the directory dma address.
    2236   00:E9D8  CD B2 E7            	CALL	DOREAD		;and read it.
    2237   00:E9DB                      ;
    2238   00:E9DB                      ;   Routine to set the dma address to the users choice.
    2239   00:E9DB                      ;
    2240   00:E9DB  21 B0 F1            DEFDMA:	LD	HL,USERDMA	;reset the default dma address and return.
    2241   00:E9DE  C3 E4 E9            	JP	DIRDMA1
    2242   00:E9E1                      ;
    2243   00:E9E1                      ;   Routine to set the dma address for directory work.
    2244   00:E9E1                      ;
    2245   00:E9E1  21 B8 F1            DIRDMA:	LD	HL,DIRBUF
    2246   00:E9E4                      ;
    2247   00:E9E4                      ;   Set the dma address. On entry, (HL) points to
    2248   00:E9E4                      ; word containing the desired dma address.
    2249   00:E9E4                      ;
    2250   00:E9E4  4E                  DIRDMA1:LD	C,(HL)
    2251   00:E9E5  23                  	INC	HL
    2252   00:E9E6  46                  	LD	B,(HL)		;setup (BC) and go to the bios to set it.
    2253   00:E9E7  C3 23 F2            	JP	SETDMA
    2254   00:E9EA                      ;
    2255   00:E9EA                      ;   Move the directory buffer into user's dma space.
    2256   00:E9EA                      ;
    2257   00:E9EA  2A B8 F1            MOVEDIR:LD	HL,(DIRBUF)	;buffer is located here, and
    2258   00:E9ED  EB                  	EX	DE,HL
    2259   00:E9EE  2A B0 F1            	LD	HL,(USERDMA)	; put it here.
    2260   00:E9F1  0E 80               	LD	C,128		;this is its length.
    2261   00:E9F3  C3 4F E7            	JP	DE2HL		;move it now and return.
    2262   00:E9F6                      ;
    2263   00:E9F6                      ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
    2264   00:E9F6                      ;
    2265   00:E9F6  21 E9 F1            CKFILPOS: LD	HL,FILEPOS
    2266   00:E9F9  7E                  	LD	A,(HL)
    2267   00:E9FA  23                  	INC	HL
    2268   00:E9FB  BE                  	CP	(HL)		;are both bytes the same?
    2269   00:E9FC  C0                  	RET	NZ
    2270   00:E9FD  3C                  	INC	A		;yes, but are they each 0ffh?
    2271   00:E9FE  C9                  	RET	
    2272   00:E9FF                      ;
    2273   00:E9FF                      ;   Set location (FILEPOS) to 0ffffh.
    2274   00:E9FF                      ;
    2275   00:E9FF  21 FF FF            STFILPOS: LD	HL,0FFFFH
    2276   00:EA02  22 E9 F1            	LD	(FILEPOS),HL
    2277   00:EA05  C9                  	RET	
    2278   00:EA06                      ;
    2279   00:EA06                      ;   Move on to the next file position within the current
    2280   00:EA06                      ; directory buffer. If no more exist, set pointer to 0ffffh
    2281   00:EA06                      ; and the calling routine will check for this. Enter with (C)
    2282   00:EA06                      ; equal to 0ffh to cause the checksum byte to be set, else we
    2283   00:EA06                      ; will check this disk and set write protect if checksums are
    2284   00:EA06                      ; not the same (applies only if another directory sector must
    2285   00:EA06                      ; be read).
    2286   00:EA06                      ;
    2287   00:EA06  2A C7 F1            NXENTRY:LD	HL,(DIRSIZE)	;get directory entry size limit.
    2288   00:EA09  EB                  	EX	DE,HL
    2289   00:EA0A  2A E9 F1            	LD	HL,(FILEPOS)	;get current count.
    2290   00:EA0D  23                  	INC	HL		;go on to the next one.
    2291   00:EA0E  22 E9 F1            	LD	(FILEPOS),HL
    2292   00:EA11  CD 96 E9            	CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
    2293   00:EA14  D2 1A EA            	JP	NC,NXENT1	;is there more room left?
    2294   00:EA17  C3 FF E9            	JP	STFILPOS	;no. Set this flag and return.
    2295   00:EA1A  3A E9 F1            NXENT1:	LD	A,(FILEPOS)	;get file position within directory.
    2296   00:EA1D  E6 03               	AND	03H		;only look within this sector (only 4 entries fit).
    2297   00:EA1F  06 05               	LD	B,5		;convert to relative position (32 bytes each).
    2298   00:EA21  87                  NXENT2:	ADD	A,A		;note that this is not efficient code.
    2299   00:EA22  05                  	DEC	B		;5 'ADD A's would be better.
    2300   00:EA23  C2 21 EA            	JP	NZ,NXENT2
    2301   00:EA26  32 E8 F1            	LD	(FCBPOS),A	;save it as position of fcb.
    2302   00:EA29  B7                  	OR	A
    2303   00:EA2A  C0                  	RET	NZ		;return if we are within buffer.
    2304   00:EA2B  C5                  	PUSH	BC
    2305   00:EA2C  CD C3 E7            	CALL	TRKSEC		;we need the next directory sector.
    2306   00:EA2F  CD D5 E9            	CALL	DIRREAD
    2307   00:EA32  C1                  	POP	BC
    2308   00:EA33  C3 9F E9            	JP	CHECKDIR
    2309   00:EA36                      ;
    2310   00:EA36                      ;   Routine to to get a bit from the disk space allocation
    2311   00:EA36                      ; map. It is returned in (A), bit position 0. On entry to here,
    2312   00:EA36                      ; set (BC) to the block number on the disk to check.
    2313   00:EA36                      ; On return, (D) will contain the original bit position for
    2314   00:EA36                      ; this block number and (HL) will point to the address for it.
    2315   00:EA36                      ;
    2316   00:EA36  79                  CKBITMAP: LD	A,C		;determine bit number of interest.
    2317   00:EA37  E6 07               	AND	07H		;compute (D)=(E)=(C and 7)+1.
    2318   00:EA39  3C                  	INC	A
    2319   00:EA3A  5F                  	LD	E,A		;save particular bit number.
    2320   00:EA3B  57                  	LD	D,A
    2321   00:EA3C                      ;
    2322   00:EA3C                      ;   compute (BC)=(BC)/8.
    2323   00:EA3C                      ;
    2324   00:EA3C  79                  	LD	A,C
    2325   00:EA3D  0F                  	RRCA			;now shift right 3 bits.
    2326   00:EA3E  0F                  	RRCA	
    2327   00:EA3F  0F                  	RRCA	
    2328   00:EA40  E6 1F               	AND	1FH		;and clear bits 7,6,5.
    2329   00:EA42  4F                  	LD	C,A
    2330   00:EA43  78                  	LD	A,B
    2331   00:EA44  87                  	ADD	A,A		;now shift (B) into bits 7,6,5.
    2332   00:EA45  87                  	ADD	A,A
    2333   00:EA46  87                  	ADD	A,A
    2334   00:EA47  87                  	ADD	A,A
    2335   00:EA48  87                  	ADD	A,A
    2336   00:EA49  B1                  	OR	C		;and add in (C).
    2337   00:EA4A  4F                  	LD	C,A		;ok, (C) ha been completed.
    2338   00:EA4B  78                  	LD	A,B		;is there a better way of doing this?
    2339   00:EA4C  0F                  	RRCA	
    2340   00:EA4D  0F                  	RRCA	
    2341   00:EA4E  0F                  	RRCA	
    2342   00:EA4F  E6 1F               	AND	1FH
    2343   00:EA51  47                  	LD	B,A		;and now (B) is completed.
    2344   00:EA52                      ;
    2345   00:EA52                      ;   use this as an offset into the disk space allocation
    2346   00:EA52                      ; table.
    2347   00:EA52                      ;
    2348   00:EA52  2A BE F1            	LD	HL,(ALOCVECT)
    2349   00:EA55  09                  	ADD	HL,BC
    2350   00:EA56  7E                  	LD	A,(HL)		;now get correct byte.
    2351   00:EA57  07                  CKBMAP1:RLCA			;get correct bit into position 0.
    2352   00:EA58  1D                  	DEC	E
    2353   00:EA59  C2 57 EA            	JP	NZ,CKBMAP1
    2354   00:EA5C  C9                  	RET	
    2355   00:EA5D                      ;
    2356   00:EA5D                      ;   Set or clear the bit map such that block number (BC) will be marked
    2357   00:EA5D                      ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
    2358   00:EA5D                      ; 1 then it will be set (don't use anyother values).
    2359   00:EA5D                      ;
    2360   00:EA5D  D5                  STBITMAP: PUSH	DE
    2361   00:EA5E  CD 36 EA            	CALL	CKBITMAP	;get the byte of interest.
    2362   00:EA61  E6 FE               	AND	0FEH		;clear the affected bit.
    2363   00:EA63  C1                  	POP	BC
    2364   00:EA64  B1                  	OR	C		;and now set it acording to (C).
    2365   00:EA65                      ;
    2366   00:EA65                      ;  entry to restore the original bit position and then store
    2367   00:EA65                      ; in table. (A) contains the value, (D) contains the bit
    2368   00:EA65                      ; position (1-8), and (HL) points to the address within the
    2369   00:EA65                      ; space allocation table for this byte.
    2370   00:EA65                      ;
    2371   00:EA65  0F                  STBMAP1:RRCA			;restore original bit position.
    2372   00:EA66  15                  	DEC	D
    2373   00:EA67  C2 65 EA            	JP	NZ,STBMAP1
    2374   00:EA6A  77                  	LD	(HL),A		;and stor byte in table.
    2375   00:EA6B  C9                  	RET	
    2376   00:EA6C                      ;
    2377   00:EA6C                      ;   Set/clear space used bits in allocation map for this file.
    2378   00:EA6C                      ; On entry, (C)=1 to set the map and (C)=0 to clear it.
    2379   00:EA6C                      ;
    2380   00:EA6C  CD 5F E9            SETFILE:CALL	FCB2HL		;get address of fcb
    2381   00:EA6F  11 10 00            	LD	DE,16
    2382   00:EA72  19                  	ADD	HL,DE		;get to block number bytes.
    2383   00:EA73  C5                  	PUSH	BC
    2384   00:EA74  0E 11               	LD	C,17		;check all 17 bytes (max) of table.
    2385   00:EA76  D1                  SETFL1:	POP	DE
    2386   00:EA77  0D                  	DEC	C		;done all bytes yet?
    2387   00:EA78  C8                  	RET	Z
    2388   00:EA79  D5                  	PUSH	DE
    2389   00:EA7A  3A DC F1            	LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
    2390   00:EA7D  B7                  	OR	A
    2391   00:EA7E  CA 89 EA            	JP	Z,SETFL2
    2392   00:EA81  C5                  	PUSH	BC		;only 8 bit numbers. set (BC) to this one.
    2393   00:EA82  E5                  	PUSH	HL
    2394   00:EA83  4E                  	LD	C,(HL)		;get low byte from table, always
    2395   00:EA84  06 00               	LD	B,0		;set high byte to zero.
    2396   00:EA86  C3 8F EA            	JP	SETFL3
    2397   00:EA89  0D                  SETFL2:	DEC	C		;for 16 bit block numbers, adjust counter.
    2398   00:EA8A  C5                  	PUSH	BC
    2399   00:EA8B  4E                  	LD	C,(HL)		;now get both the low and high bytes.
    2400   00:EA8C  23                  	INC	HL
    2401   00:EA8D  46                  	LD	B,(HL)
    2402   00:EA8E  E5                  	PUSH	HL
    2403   00:EA8F  79                  SETFL3:	LD	A,C		;block used?
    2404   00:EA90  B0                  	OR	B
    2405   00:EA91  CA 9E EA            	JP	Z,SETFL4
    2406   00:EA94  2A C5 F1            	LD	HL,(DSKSIZE)	;is this block number within the
    2407   00:EA97  7D                  	LD	A,L		;space on the disk?
    2408   00:EA98  91                  	SUB	C
    2409   00:EA99  7C                  	LD	A,H
    2410   00:EA9A  98                  	SBC	A,B
    2411   00:EA9B  D4 5D EA            	CALL	NC,STBITMAP	;yes, set the proper bit.
    2412   00:EA9E  E1                  SETFL4:	POP	HL		;point to next block number in fcb.
    2413   00:EA9F  23                  	INC	HL
    2414   00:EAA0  C1                  	POP	BC
    2415   00:EAA1  C3 76 EA            	JP	SETFL1
    2416   00:EAA4                      ;
    2417   00:EAA4                      ;   Construct the space used allocation bit map for the active
    2418   00:EAA4                      ; drive. If a file name starts with '$' and it is under the
    2419   00:EAA4                      ; current user number, then (STATUS) is set to minus 1. Otherwise
    2420   00:EAA4                      ; it is not set at all.
    2421   00:EAA4                      ;
    2422   00:EAA4  2A C5 F1            BITMAP:	LD	HL,(DSKSIZE)	;compute size of allocation table.
    2423   00:EAA7  0E 03               	LD	C,3
    2424   00:EAA9  CD EA E8            	CALL	SHIFTR		;(HL)=(HL)/8.
    2425   00:EAAC  23                  	INC	HL		;at lease 1 byte.
    2426   00:EAAD  44                  	LD	B,H
    2427   00:EAAE  4D                  	LD	C,L		;set (BC) to the allocation table length.
    2428   00:EAAF                      ;
    2429   00:EAAF                      ;   Initialize the bitmap for this drive. Right now, the first
    2430   00:EAAF                      ; two bytes are specified by the disk parameter block. However
    2431   00:EAAF                      ; a patch could be entered here if it were necessary to setup
    2432   00:EAAF                      ; this table in a special mannor. For example, the bios could
    2433   00:EAAF                      ; determine locations of 'bad blocks' and set them as already
    2434   00:EAAF                      ; 'used' in the map.
    2435   00:EAAF                      ;
    2436   00:EAAF  2A BE F1            	LD	HL,(ALOCVECT)	;now zero out the table now.
    2437   00:EAB2  36 00               BITMAP1:LD	(HL),0
    2438   00:EAB4  23                  	INC	HL
    2439   00:EAB5  0B                  	DEC	BC
    2440   00:EAB6  78                  	LD	A,B
    2441   00:EAB7  B1                  	OR	C
    2442   00:EAB8  C2 B2 EA            	JP	NZ,BITMAP1
    2443   00:EABB  2A C9 F1            	LD	HL,(ALLOC0)	;get initial space used by directory.
    2444   00:EABE  EB                  	EX	DE,HL
    2445   00:EABF  2A BE F1            	LD	HL,(ALOCVECT)	;and put this into map.
    2446   00:EAC2  73                  	LD	(HL),E
    2447   00:EAC3  23                  	INC	HL
    2448   00:EAC4  72                  	LD	(HL),D
    2449   00:EAC5                      ;
    2450   00:EAC5                      ;   End of initialization portion.
    2451   00:EAC5                      ;
    2452   00:EAC5  CD A1 E7            	CALL	HOMEDRV		;now home the drive.
    2453   00:EAC8  2A B2 F1            	LD	HL,(SCRATCH1)
    2454   00:EACB  36 03               	LD	(HL),3		;force next directory request to read
    2455   00:EACD  23                  	INC	HL		;in a sector.
    2456   00:EACE  36 00               	LD	(HL),0
    2457   00:EAD0  CD FF E9            	CALL	STFILPOS	;clear initial file position also.
    2458   00:EAD3  0E FF               BITMAP2:LD	C,0FFH		;read next file name in directory
    2459   00:EAD5  CD 06 EA            	CALL	NXENTRY		;and set checksum byte.
    2460   00:EAD8  CD F6 E9            	CALL	CKFILPOS	;is there another file?
    2461   00:EADB  C8                  	RET	Z
    2462   00:EADC  CD 5F E9            	CALL	FCB2HL		;yes, get its address.
    2463   00:EADF  3E E5               	LD	A,0E5H
    2464   00:EAE1  BE                  	CP	(HL)		;empty file entry?
    2465   00:EAE2  CA D3 EA            	JP	Z,BITMAP2
    2466   00:EAE5  3A 41 E7            	LD	A,(USERNO)	;no, correct user number?
    2467   00:EAE8  BE                  	CP	(HL)
    2468   00:EAE9  C2 F7 EA            	JP	NZ,BITMAP3
    2469   00:EAEC  23                  	INC	HL
    2470   00:EAED  7E                  	LD	A,(HL)		;yes, does name start with a '$'?
    2471   00:EAEE  D6 24               	SUB	'$'
    2472   00:EAF0  C2 F7 EA            	JP	NZ,BITMAP3
    2473   00:EAF3  3D                  	DEC	A		;yes, set atatus to minus one.
    2474   00:EAF4  32 45 E7            	LD	(STATUS),A
    2475   00:EAF7  0E 01               BITMAP3:LD	C,1		;now set this file's space as used in bit map.
    2476   00:EAF9  CD 6C EA            	CALL	SETFILE
    2477   00:EAFC  CD 8D E9            	CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
    2478   00:EAFF  C3 D3 EA            	JP	BITMAP2
    2479   00:EB02                      ;
    2480   00:EB02                      ;   Set the status (STATUS) and return.
    2481   00:EB02                      ;
    2482   00:EB02  3A D3 F1            STSTATUS: LD	A,(FNDSTAT)
    2483   00:EB05  C3 01 E7            	JP	SETSTAT
    2484   00:EB08                      ;
    2485   00:EB08                      ;   Check extents in (A) and (C). Set the zero flag if they
    2486   00:EB08                      ; are the same. The number of 16k chunks of disk space that
    2487   00:EB08                      ; the directory extent covers is expressad is (EXTMASK+1).
    2488   00:EB08                      ; No registers are modified.
    2489   00:EB08                      ;
    2490   00:EB08  C5                  SAMEXT:	PUSH	BC
    2491   00:EB09  F5                  	PUSH	AF
    2492   00:EB0A  3A C4 F1            	LD	A,(EXTMASK)	;get extent mask and use it to
    2493   00:EB0D  2F                  	CPL			;to compare both extent numbers.
    2494   00:EB0E  47                  	LD	B,A		;save resulting mask here.
    2495   00:EB0F  79                  	LD	A,C		;mask first extent and save in (C).
    2496   00:EB10  A0                  	AND	B
    2497   00:EB11  4F                  	LD	C,A
    2498   00:EB12  F1                  	POP	AF		;now mask second extent and compare
    2499   00:EB13  A0                  	AND	B		;with the first one.
    2500   00:EB14  91                  	SUB	C
    2501   00:EB15  E6 1F               	AND	1FH		;(* only check buts 0-4 *)
    2502   00:EB17  C1                  	POP	BC		;the zero flag is set if they are the same.
    2503   00:EB18  C9                  	RET			;restore (BC) and return.
    2504   00:EB19                      ;
    2505   00:EB19                      ;   Search for the first occurence of a file name. On entry,
    2506   00:EB19                      ; register (C) should contain the number of bytes of the fcb
    2507   00:EB19                      ; that must match.
    2508   00:EB19                      ;
    2509   00:EB19  3E FF               FINDFST:LD	A,0FFH
    2510   00:EB1B  32 D3 F1            	LD	(FNDSTAT),A
    2511   00:EB1E  21 D7 F1            	LD	HL,COUNTER	;save character count.
    2512   00:EB21  71                  	LD	(HL),C
    2513   00:EB22  2A 43 E7            	LD	HL,(PARAMS)	;get filename to match.
    2514   00:EB25  22 D8 F1            	LD	(SAVEFCB),HL	;and save.
    2515   00:EB28  CD FF E9            	CALL	STFILPOS	;clear initial file position (set to 0ffffh).
    2516   00:EB2B  CD A1 E7            	CALL	HOMEDRV		;home the drive.
    2517   00:EB2E                      ;
    2518   00:EB2E                      ;   Entry to locate the next occurence of a filename within the
    2519   00:EB2E                      ; directory. The disk is not expected to have been changed. If
    2520   00:EB2E                      ; it was, then it will be write protected.
    2521   00:EB2E                      ;
    2522   00:EB2E  0E 00               FINDNXT:LD	C,0		;write protect the disk if changed.
    2523   00:EB30  CD 06 EA            	CALL	NXENTRY		;get next filename entry in directory.
    2524   00:EB33  CD F6 E9            	CALL	CKFILPOS	;is file position = 0ffffh?
    2525   00:EB36  CA 95 EB            	JP	Z,FNDNXT6	;yes, exit now then.
    2526   00:EB39  2A D8 F1            	LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
    2527   00:EB3C  EB                  	EX	DE,HL
    2528   00:EB3D  1A                  	LD	A,(DE)
    2529   00:EB3E  FE E5               	CP	0E5H		;empty directory entry?
    2530   00:EB40  CA 4B EB            	JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *)
    2531   00:EB43  D5                  	PUSH	DE
    2532   00:EB44  CD 80 E9            	CALL	MOREFLS		;more files in directory?
    2533   00:EB47  D1                  	POP	DE
    2534   00:EB48  D2 95 EB            	JP	NC,FNDNXT6	;no more. Exit now.
    2535   00:EB4B  CD 5F E9            FNDNXT1:CALL	FCB2HL		;get address of this fcb in directory.
    2536   00:EB4E  3A D7 F1            	LD	A,(COUNTER)	;get number of bytes (characters) to check.
    2537   00:EB51  4F                  	LD	C,A
    2538   00:EB52  06 00               	LD	B,0		;initialize byte position counter.
    2539   00:EB54  79                  FNDNXT2:LD	A,C		;are we done with the compare?
    2540   00:EB55  B7                  	OR	A
    2541   00:EB56  CA 84 EB            	JP	Z,FNDNXT5
    2542   00:EB59  1A                  	LD	A,(DE)		;no, check next byte.
    2543   00:EB5A  FE 3F               	CP	'?'		;don't care about this character?
    2544   00:EB5C  CA 7D EB            	JP	Z,FNDNXT4
    2545   00:EB5F  78                  	LD	A,B		;get bytes position in fcb.
    2546   00:EB60  FE 0D               	CP	13		;don't care about the thirteenth byte either.
    2547   00:EB62  CA 7D EB            	JP	Z,FNDNXT4
    2548   00:EB65  FE 0C               	CP	12		;extent byte?
    2549   00:EB67  1A                  	LD	A,(DE)
    2550   00:EB68  CA 74 EB            	JP	Z,FNDNXT3
    2551   00:EB6B  96                  	SUB	(HL)		;otherwise compare characters.
    2552   00:EB6C  E6 7F               	AND	7FH
    2553   00:EB6E  C2 2E EB            	JP	NZ,FINDNXT	;not the same, check next entry.
    2554   00:EB71  C3 7D EB            	JP	FNDNXT4		;so far so good, keep checking.
    2555   00:EB74  C5                  FNDNXT3:PUSH	BC		;check the extent byte here.
    2556   00:EB75  4E                  	LD	C,(HL)
    2557   00:EB76  CD 08 EB            	CALL	SAMEXT
    2558   00:EB79  C1                  	POP	BC
    2559   00:EB7A  C2 2E EB            	JP	NZ,FINDNXT	;not the same, look some more.
    2560   00:EB7D                      ;
    2561   00:EB7D                      ;   So far the names compare. Bump pointers to the next byte
    2562   00:EB7D                      ; and continue until all (C) characters have been checked.
    2563   00:EB7D                      ;
    2564   00:EB7D  13                  FNDNXT4:INC	DE		;bump pointers.
    2565   00:EB7E  23                  	INC	HL
    2566   00:EB7F  04                  	INC	B
    2567   00:EB80  0D                  	DEC	C		;adjust character counter.
    2568   00:EB81  C3 54 EB            	JP	FNDNXT2
    2569   00:EB84  3A E9 F1            FNDNXT5:LD	A,(FILEPOS)	;return the position of this entry.
    2570   00:EB87  E6 03               	AND	03H
    2571   00:EB89  32 45 E7            	LD	(STATUS),A
    2572   00:EB8C  21 D3 F1            	LD	HL,FNDSTAT
    2573   00:EB8F  7E                  	LD	A,(HL)
    2574   00:EB90  17                  	RLA	
    2575   00:EB91  D0                  	RET	NC
    2576   00:EB92  AF                  	XOR	A
    2577   00:EB93  77                  	LD	(HL),A
    2578   00:EB94  C9                  	RET	
    2579   00:EB95                      ;
    2580   00:EB95                      ;   Filename was not found. Set appropriate status.
    2581   00:EB95                      ;
    2582   00:EB95  CD FF E9            FNDNXT6:CALL	STFILPOS	;set (FILEPOS) to 0ffffh.
    2583   00:EB98  3E FF               	LD	A,0FFH		;say not located.
    2584   00:EB9A  C3 01 E7            	JP	SETSTAT
    2585   00:EB9D                      ;
    2586   00:EB9D                      ;   Erase files from the directory. Only the first byte of the
    2587   00:EB9D                      ; fcb will be affected. It is set to (E5).
    2588   00:EB9D                      ;
    2589   00:EB9D  CD 55 E9            ERAFILE:CALL	CHKWPRT		;is disk write protected?
    2590   00:EBA0  0E 0C               	LD	C,12		;only compare file names.
    2591   00:EBA2  CD 19 EB            	CALL	FINDFST		;get first file name.
    2592   00:EBA5  CD F6 E9            ERAFIL1:CALL	CKFILPOS	;any found?
    2593   00:EBA8  C8                  	RET	Z		;nope, we must be done.
    2594   00:EBA9  CD 45 E9            	CALL	CHKROFL		;is file read only?
    2595   00:EBAC  CD 5F E9            	CALL	FCB2HL		;nope, get address of fcb and
    2596   00:EBAF  36 E5               	LD	(HL),0E5H	;set first byte to 'empty'.
    2597   00:EBB1  0E 00               	LD	C,0		;clear the space from the bit map.
    2598   00:EBB3  CD 6C EA            	CALL	SETFILE
    2599   00:EBB6  CD C7 E9            	CALL	DIRWRITE	;now write the directory sector back out.
    2600   00:EBB9  CD 2E EB            	CALL	FINDNXT		;find the next file name.
    2601   00:EBBC  C3 A5 EB            	JP	ERAFIL1		;and repeat process.
    2602   00:EBBF                      ;
    2603   00:EBBF                      ;   Look through the space allocation map (bit map) for the
    2604   00:EBBF                      ; next available block. Start searching at block number (BC-1).
    2605   00:EBBF                      ; The search procedure is to look for an empty block that is
    2606   00:EBBF                      ; before the starting block. If not empty, look at a later
    2607   00:EBBF                      ; block number. In this way, we return the closest empty block
    2608   00:EBBF                      ; on either side of the 'target' block number. This will speed
    2609   00:EBBF                      ; access on random devices. For serial devices, this should be
    2610   00:EBBF                      ; changed to look in the forward direction first and then start
    2611   00:EBBF                      ; at the front and search some more.
    2612   00:EBBF                      ;
    2613   00:EBBF                      ;   On return, (DE)= block number that is empty and (HL) =0
    2614   00:EBBF                      ; if no empry block was found.
    2615   00:EBBF                      ;
    2616   00:EBBF  50                  FNDSPACE: LD	D,B		;set (DE) as the block that is checked.
    2617   00:EBC0  59                  	LD	E,C
    2618   00:EBC1                      ;
    2619   00:EBC1                      ;   Look before target block. Registers (BC) are used as the lower
    2620   00:EBC1                      ; pointer and (DE) as the upper pointer.
    2621   00:EBC1                      ;
    2622   00:EBC1  79                  FNDSPA1:LD	A,C		;is block 0 specified?
    2623   00:EBC2  B0                  	OR	B
    2624   00:EBC3  CA D2 EB            	JP	Z,FNDSPA2
    2625   00:EBC6  0B                  	DEC	BC		;nope, check previous block.
    2626   00:EBC7  D5                  	PUSH	DE
    2627   00:EBC8  C5                  	PUSH	BC
    2628   00:EBC9  CD 36 EA            	CALL	CKBITMAP
    2629   00:EBCC  1F                  	RRA			;is this block empty?
    2630   00:EBCD  D2 ED EB            	JP	NC,FNDSPA3	;yes. use this.
    2631   00:EBD0                      ;
    2632   00:EBD0                      ;   Note that the above logic gets the first block that it finds
    2633   00:EBD0                      ; that is empty. Thus a file could be written 'backward' making
    2634   00:EBD0                      ; it very slow to access. This could be changed to look for the
    2635   00:EBD0                      ; first empty block and then continue until the start of this
    2636   00:EBD0                      ; empty space is located and then used that starting block.
    2637   00:EBD0                      ; This should help speed up access to some files especially on
    2638   00:EBD0                      ; a well used disk with lots of fairly small 'holes'.
    2639   00:EBD0                      ;
    2640   00:EBD0  C1                  	POP	BC		;nope, check some more.
    2641   00:EBD1  D1                  	POP	DE
    2642   00:EBD2                      ;
    2643   00:EBD2                      ;   Now look after target block.
    2644   00:EBD2                      ;
    2645   00:EBD2  2A C5 F1            FNDSPA2:LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
    2646   00:EBD5  7B                  	LD	A,E
    2647   00:EBD6  95                  	SUB	L
    2648   00:EBD7  7A                  	LD	A,D
    2649   00:EBD8  9C                  	SBC	A,H
    2650   00:EBD9  D2 F5 EB            	JP	NC,FNDSPA4
    2651   00:EBDC  13                  	INC	DE		;yes, move on to next one.
    2652   00:EBDD  C5                  	PUSH	BC
    2653   00:EBDE  D5                  	PUSH	DE
    2654   00:EBDF  42                  	LD	B,D
    2655   00:EBE0  4B                  	LD	C,E
    2656   00:EBE1  CD 36 EA            	CALL	CKBITMAP	;check it.
    2657   00:EBE4  1F                  	RRA			;empty?
    2658   00:EBE5  D2 ED EB            	JP	NC,FNDSPA3
    2659   00:EBE8  D1                  	POP	DE		;nope, continue searching.
    2660   00:EBE9  C1                  	POP	BC
    2661   00:EBEA  C3 C1 EB            	JP	FNDSPA1
    2662   00:EBED                      ;
    2663   00:EBED                      ;   Empty block found. Set it as used and return with (HL)
    2664   00:EBED                      ; pointing to it (true?).
    2665   00:EBED                      ;
    2666   00:EBED  17                  FNDSPA3:RLA			;reset byte.
    2667   00:EBEE  3C                  	INC	A		;and set bit 0.
    2668   00:EBEF  CD 65 EA            	CALL	STBMAP1		;update bit map.
    2669   00:EBF2  E1                  	POP	HL		;set return registers.
    2670   00:EBF3  D1                  	POP	DE
    2671   00:EBF4  C9                  	RET	
    2672   00:EBF5                      ;
    2673   00:EBF5                      ;   Free block was not found. If (BC) is not zero, then we have
    2674   00:EBF5                      ; not checked all of the disk space.
    2675   00:EBF5                      ;
    2676   00:EBF5  79                  FNDSPA4:LD	A,C
    2677   00:EBF6  B0                  	OR	B
    2678   00:EBF7  C2 C1 EB            	JP	NZ,FNDSPA1
    2679   00:EBFA  21 00 00            	LD	HL,0		;set 'not found' status.
    2680   00:EBFD  C9                  	RET	
    2681   00:EBFE                      ;
    2682   00:EBFE                      ;   Move a complete fcb entry into the directory and write it.
    2683   00:EBFE                      ;
    2684   00:EBFE  0E 00               FCBSET:	LD	C,0
    2685   00:EC00  1E 20               	LD	E,32		;length of each entry.
    2686   00:EC02                      ;
    2687   00:EC02                      ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
    2688   00:EC02                      ; fcb in directory starting at relative byte (C). This updated
    2689   00:EC02                      ; directory buffer is then written to the disk.
    2690   00:EC02                      ;
    2691   00:EC02  D5                  UPDATE:	PUSH	DE
    2692   00:EC03  06 00               	LD	B,0		;set (BC) to relative byte position.
    2693   00:EC05  2A 43 E7            	LD	HL,(PARAMS)	;get address of fcb.
    2694   00:EC08  09                  	ADD	HL,BC		;compute starting byte.
    2695   00:EC09  EB                  	EX	DE,HL
    2696   00:EC0A  CD 5F E9            	CALL	FCB2HL		;get address of fcb to update in directory.
    2697   00:EC0D  C1                  	POP	BC		;set (C) to number of bytes to change.
    2698   00:EC0E  CD 4F E7            	CALL	DE2HL
    2699   00:EC11  CD C3 E7            UPDATE1:CALL	TRKSEC		;determine the track and sector affected.
    2700   00:EC14  C3 C7 E9            	JP	DIRWRITE	;then write this sector out.
    2701   00:EC17                      ;
    2702   00:EC17                      ;   Routine to change the name of all files on the disk with a
    2703   00:EC17                      ; specified name. The fcb contains the current name as the
    2704   00:EC17                      ; first 12 characters and the new name 16 bytes into the fcb.
    2705   00:EC17                      ;
    2706   00:EC17  CD 55 E9            CHGNAMES: CALL	CHKWPRT		;check for a write protected disk.
    2707   00:EC1A  0E 0C               	LD	C,12		;match first 12 bytes of fcb only.
    2708   00:EC1C  CD 19 EB            	CALL	FINDFST		;get first name.
    2709   00:EC1F  2A 43 E7            	LD	HL,(PARAMS)	;get address of fcb.
    2710   00:EC22  7E                  	LD	A,(HL)		;get user number.
    2711   00:EC23  11 10 00            	LD	DE,16		;move over to desired name.
    2712   00:EC26  19                  	ADD	HL,DE
    2713   00:EC27  77                  	LD	(HL),A		;keep same user number.
    2714   00:EC28  CD F6 E9            CHGNAM1:CALL	CKFILPOS	;any matching file found?
    2715   00:EC2B  C8                  	RET	Z		;no, we must be done.
    2716   00:EC2C  CD 45 E9            	CALL	CHKROFL		;check for read only file.
    2717   00:EC2F  0E 10               	LD	C,16		;start 16 bytes into fcb.
    2718   00:EC31  1E 0C               	LD	E,12		;and update the first 12 bytes of directory.
    2719   00:EC33  CD 02 EC            	CALL	UPDATE
    2720   00:EC36  CD 2E EB            	CALL	FINDNXT		;get te next file name.
    2721   00:EC39  C3 28 EC            	JP	CHGNAM1		;and continue.
    2722   00:EC3C                      ;
    2723   00:EC3C                      ;   Update a files attributes. The procedure is to search for
    2724   00:EC3C                      ; every file with the same name as shown in fcb (ignoring bit 7)
    2725   00:EC3C                      ; and then to update it (which includes bit 7). No other changes
    2726   00:EC3C                      ; are made.
    2727   00:EC3C                      ;
    2728   00:EC3C  0E 0C               SAVEATTR: LD	C,12		;match first 12 bytes.
    2729   00:EC3E  CD 19 EB            	CALL	FINDFST		;look for first filename.
    2730   00:EC41  CD F6 E9            SAVATR1:CALL	CKFILPOS	;was one found?
    2731   00:EC44  C8                  	RET	Z		;nope, we must be done.
    2732   00:EC45  0E 00               	LD	C,0		;yes, update the first 12 bytes now.
    2733   00:EC47  1E 0C               	LD	E,12
    2734   00:EC49  CD 02 EC            	CALL	UPDATE		;update filename and write directory.
    2735   00:EC4C  CD 2E EB            	CALL	FINDNXT		;and get the next file.
    2736   00:EC4F  C3 41 EC            	JP	SAVATR1		;then continue until done.
    2737   00:EC52                      ;
    2738   00:EC52                      ;  Open a file (name specified in fcb).
    2739   00:EC52                      ;
    2740   00:EC52  0E 0F               OPENIT:	LD	C,15		;compare the first 15 bytes.
    2741   00:EC54  CD 19 EB            	CALL	FINDFST		;get the first one in directory.
    2742   00:EC57  CD F6 E9            	CALL	CKFILPOS	;any at all?
    2743   00:EC5A  C8                  	RET	Z
    2744   00:EC5B  CD A6 E8            OPENIT1:CALL	SETEXT		;point to extent byte within users fcb.
    2745   00:EC5E  7E                  	LD	A,(HL)		;and get it.
    2746   00:EC5F  F5                  	PUSH	AF		;save it and address.
    2747   00:EC60  E5                  	PUSH	HL
    2748   00:EC61  CD 5F E9            	CALL	FCB2HL		;point to fcb in directory.
    2749   00:EC64  EB                  	EX	DE,HL
    2750   00:EC65  2A 43 E7            	LD	HL,(PARAMS)	;this is the users copy.
    2751   00:EC68  0E 20               	LD	C,32		;move it into users space.
    2752   00:EC6A  D5                  	PUSH	DE
    2753   00:EC6B  CD 4F E7            	CALL	DE2HL
    2754   00:EC6E  CD 79 E9            	CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
    2755   00:EC71  D1                  	POP	DE		;now get the extent byte from this fcb.
    2756   00:EC72  21 0C 00            	LD	HL,12
    2757   00:EC75  19                  	ADD	HL,DE
    2758   00:EC76  4E                  	LD	C,(HL)		;into (C).
    2759   00:EC77  21 0F 00            	LD	HL,15		;now get the record count byte into (B).
    2760   00:EC7A  19                  	ADD	HL,DE
    2761   00:EC7B  46                  	LD	B,(HL)
    2762   00:EC7C  E1                  	POP	HL		;keep the same extent as the user had originally.
    2763   00:EC7D  F1                  	POP	AF
    2764   00:EC7E  77                  	LD	(HL),A
    2765   00:EC7F  79                  	LD	A,C		;is it the same as in the directory fcb?
    2766   00:EC80  BE                  	CP	(HL)
    2767   00:EC81  78                  	LD	A,B		;if yes, then use the same record count.
    2768   00:EC82  CA 8C EC            	JP	Z,OPENIT2
    2769   00:EC85  3E 00               	LD	A,0		;if the user specified an extent greater than
    2770   00:EC87  DA 8C EC            	JP	C,OPENIT2	;the one in the directory, then set record count to 0.
    2771   00:EC8A  3E 80               	LD	A,128		;otherwise set to maximum.
    2772   00:EC8C  2A 43 E7            OPENIT2:LD	HL,(PARAMS)	;set record count in users fcb to (A).
    2773   00:EC8F  11 0F 00            	LD	DE,15
    2774   00:EC92  19                  	ADD	HL,DE		;compute relative position.
    2775   00:EC93  77                  	LD	(HL),A		;and set the record count.
    2776   00:EC94  C9                  	RET	
    2777   00:EC95                      ;
    2778   00:EC95                      ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
    2779   00:EC95                      ; point to a zero value (16 bit).
    2780   00:EC95                      ;   Return with zero flag set it (DE) was moved. Registers (DE)
    2781   00:EC95                      ; and (HL) are not changed. However (A) is.
    2782   00:EC95                      ;
    2783   00:EC95  7E                  MOVEWORD: LD	A,(HL)		;check for a zero word.
    2784   00:EC96  23                  	INC	HL
    2785   00:EC97  B6                  	OR	(HL)		;both bytes zero?
    2786   00:EC98  2B                  	DEC	HL
    2787   00:EC99  C0                  	RET	NZ		;nope, just return.
    2788   00:EC9A  1A                  	LD	A,(DE)		;yes, move two bytes from (DE) into
    2789   00:EC9B  77                  	LD	(HL),A		;this zero space.
    2790   00:EC9C  13                  	INC	DE
    2791   00:EC9D  23                  	INC	HL
    2792   00:EC9E  1A                  	LD	A,(DE)
    2793   00:EC9F  77                  	LD	(HL),A
    2794   00:ECA0  1B                  	DEC	DE		;don't disturb these registers.
    2795   00:ECA1  2B                  	DEC	HL
    2796   00:ECA2  C9                  	RET	
    2797   00:ECA3                      ;
    2798   00:ECA3                      ;   Get here to close a file specified by (fcb).
    2799   00:ECA3                      ;
    2800   00:ECA3  AF                  CLOSEIT:XOR	A		;clear status and file position bytes.
    2801   00:ECA4  32 45 E7            	LD	(STATUS),A
    2802   00:ECA7  32 E9 F1            	LD	(FILEPOS),A
    2803   00:ECAA  32 EA F1            	LD	(FILEPOS+1),A
    2804   00:ECAD  CD 1F E9            	CALL	GETWPRT		;get write protect bit for this drive.
    2805   00:ECB0  C0                  	RET	NZ		;just return if it is set.
    2806   00:ECB1  CD 6A E9            	CALL	GETS2		;else get the 's2' byte.
    2807   00:ECB4  E6 80               	AND	80H		;and look at bit 7 (file unmodified?).
    2808   00:ECB6  C0                  	RET	NZ		;just return if set.
    2809   00:ECB7  0E 0F               	LD	C,15		;else look up this file in directory.
    2810   00:ECB9  CD 19 EB            	CALL	FINDFST
    2811   00:ECBC  CD F6 E9            	CALL	CKFILPOS	;was it found?
    2812   00:ECBF  C8                  	RET	Z		;just return if not.
    2813   00:ECC0  01 10 00            	LD	BC,16		;set (HL) pointing to records used section.
    2814   00:ECC3  CD 5F E9            	CALL	FCB2HL
    2815   00:ECC6  09                  	ADD	HL,BC
    2816   00:ECC7  EB                  	EX	DE,HL
    2817   00:ECC8  2A 43 E7            	LD	HL,(PARAMS)	;do the same for users specified fcb.
    2818   00:ECCB  09                  	ADD	HL,BC
    2819   00:ECCC  0E 10               	LD	C,16		;this many bytes are present in this extent.
    2820   00:ECCE  3A DC F1            CLOSEIT1: LD	A,(BIGDISK)	;8 or 16 bit record numbers?
    2821   00:ECD1  B7                  	OR	A
    2822   00:ECD2  CA E9 EC            	JP	Z,CLOSEIT4
    2823   00:ECD5  7E                  	LD	A,(HL)		;just 8 bit. Get one from users fcb.
    2824   00:ECD6  B7                  	OR	A
    2825   00:ECD7  1A                  	LD	A,(DE)		;now get one from directory fcb.
    2826   00:ECD8  C2 DC EC            	JP	NZ,CLOSEIT2
    2827   00:ECDB  77                  	LD	(HL),A		;users byte was zero. Update from directory.
    2828   00:ECDC  B7                  CLOSEIT2: OR	A
    2829   00:ECDD  C2 E2 EC            	JP	NZ,CLOSEIT3
    2830   00:ECE0  7E                  	LD	A,(HL)		;directories byte was zero, update from users fcb.
    2831   00:ECE1  12                  	LD	(DE),A
    2832   00:ECE2  BE                  CLOSEIT3: CP	(HL)		;if neither one of these bytes were zero,
    2833   00:ECE3  C2 20 ED            	JP	NZ,CLOSEIT7	;then close error if they are not the same.
    2834   00:ECE6  C3 FE EC            	JP	CLOSEIT5	;ok so far, get to next byte in fcbs.
    2835   00:ECE9  CD 95 EC            CLOSEIT4: CALL	MOVEWORD	;update users fcb if it is zero.
    2836   00:ECEC  EB                  	EX	DE,HL
    2837   00:ECED  CD 95 EC            	CALL	MOVEWORD	;update directories fcb if it is zero.
    2838   00:ECF0  EB                  	EX	DE,HL
    2839   00:ECF1  1A                  	LD	A,(DE)		;if these two values are no different,
    2840   00:ECF2  BE                  	CP	(HL)		;then a close error occured.
    2841   00:ECF3  C2 20 ED            	JP	NZ,CLOSEIT7
    2842   00:ECF6  13                  	INC	DE		;check second byte.
    2843   00:ECF7  23                  	INC	HL
    2844   00:ECF8  1A                  	LD	A,(DE)
    2845   00:ECF9  BE                  	CP	(HL)
    2846   00:ECFA  C2 20 ED            	JP	NZ,CLOSEIT7
    2847   00:ECFD  0D                  	DEC	C		;remember 16 bit values.
    2848   00:ECFE  13                  CLOSEIT5: INC	DE		;bump to next item in table.
    2849   00:ECFF  23                  	INC	HL
    2850   00:ED00  0D                  	DEC	C		;there are 16 entries only.
    2851   00:ED01  C2 CE EC            	JP	NZ,CLOSEIT1	;continue if more to do.
    2852   00:ED04  01 EC FF            	LD	BC,0FFECH	;backup 20 places (extent byte).
    2853   00:ED07  09                  	ADD	HL,BC
    2854   00:ED08  EB                  	EX	DE,HL
    2855   00:ED09  09                  	ADD	HL,BC
    2856   00:ED0A  1A                  	LD	A,(DE)
    2857   00:ED0B  BE                  	CP	(HL)		;directory's extent already greater than the
    2858   00:ED0C  DA 18 ED            	JP	C,CLOSEIT6	;users extent?
    2859   00:ED0F  77                  	LD	(HL),A		;no, update directory extent.
    2860   00:ED10  01 03 00            	LD	BC,3		;and update the record count byte in
    2861   00:ED13  09                  	ADD	HL,BC		;directories fcb.
    2862   00:ED14  EB                  	EX	DE,HL
    2863   00:ED15  09                  	ADD	HL,BC
    2864   00:ED16  7E                  	LD	A,(HL)		;get from user.
    2865   00:ED17  12                  	LD	(DE),A		;and put in directory.
    2866   00:ED18  3E FF               CLOSEIT6: LD	A,0FFH		;set 'was open and is now closed' byte.
    2867   00:ED1A  32 D1 F1            	LD	(CLOSEFLG),A
    2868   00:ED1D  C3 11 EC            	JP	UPDATE1		;update the directory now.
    2869   00:ED20  21 45 E7            CLOSEIT7: LD	HL,STATUS	;set return status and then return.
    2870   00:ED23  35                  	DEC	(HL)
    2871   00:ED24  C9                  	RET	
    2872   00:ED25                      ;
    2873   00:ED25                      ;   Routine to get the next empty space in the directory. It
    2874   00:ED25                      ; will then be cleared for use.
    2875   00:ED25                      ;
    2876   00:ED25  CD 55 E9            GETEMPTY: CALL	CHKWPRT		;make sure disk is not write protected.
    2877   00:ED28  2A 43 E7            	LD	HL,(PARAMS)	;save current parameters (fcb).
    2878   00:ED2B  E5                  	PUSH	HL
    2879   00:ED2C  21 AB F1            	LD	HL,EMPTYFCB	;use special one for empty space.
    2880   00:ED2F  22 43 E7            	LD	(PARAMS),HL
    2881   00:ED32  0E 01               	LD	C,1		;search for first empty spot in directory.
    2882   00:ED34  CD 19 EB            	CALL	FINDFST		;(* only check first byte *)
    2883   00:ED37  CD F6 E9            	CALL	CKFILPOS	;none?
    2884   00:ED3A  E1                  	POP	HL
    2885   00:ED3B  22 43 E7            	LD	(PARAMS),HL	;restore original fcb address.
    2886   00:ED3E  C8                  	RET	Z		;return if no more space.
    2887   00:ED3F  EB                  	EX	DE,HL
    2888   00:ED40  21 0F 00            	LD	HL,15		;point to number of records for this file.
    2889   00:ED43  19                  	ADD	HL,DE
    2890   00:ED44  0E 11               	LD	C,17		;and clear all of this space.
    2891   00:ED46  AF                  	XOR	A
    2892   00:ED47  77                  GETMT1:	LD	(HL),A
    2893   00:ED48  23                  	INC	HL
    2894   00:ED49  0D                  	DEC	C
    2895   00:ED4A  C2 47 ED            	JP	NZ,GETMT1
    2896   00:ED4D  21 0D 00            	LD	HL,13		;clear the 's1' byte also.
    2897   00:ED50  19                  	ADD	HL,DE
    2898   00:ED51  77                  	LD	(HL),A
    2899   00:ED52  CD 8D E9            	CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
    2900   00:ED55  CD FE EB            	CALL	FCBSET		;write out this fcb entry to directory.
    2901   00:ED58  C3 79 E9            	JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
    2902   00:ED5B                      ;
    2903   00:ED5B                      ;   Routine to close the current extent and open the next one
    2904   00:ED5B                      ; for reading.
    2905   00:ED5B                      ;
    2906   00:ED5B  AF                  GETNEXT:XOR	A
    2907   00:ED5C  32 D1 F1            	LD	(CLOSEFLG),A	;clear close flag.
    2908   00:ED5F  CD A3 EC            	CALL	CLOSEIT		;close this extent.
    2909   00:ED62  CD F6 E9            	CALL	CKFILPOS
    2910   00:ED65  C8                  	RET	Z		;not there???
    2911   00:ED66  2A 43 E7            	LD	HL,(PARAMS)	;get extent byte.
    2912   00:ED69  01 0C 00            	LD	BC,12
    2913   00:ED6C  09                  	ADD	HL,BC
    2914   00:ED6D  7E                  	LD	A,(HL)		;and increment it.
    2915   00:ED6E  3C                  	INC	A
    2916   00:ED6F  E6 1F               	AND	1FH		;keep within range 0-31.
    2917   00:ED71  77                  	LD	(HL),A
    2918   00:ED72  CA 84 ED            	JP	Z,GTNEXT1	;overflow?
    2919   00:ED75  47                  	LD	B,A		;mask extent byte.
    2920   00:ED76  3A C4 F1            	LD	A,(EXTMASK)
    2921   00:ED79  A0                  	AND	B
    2922   00:ED7A  21 D1 F1            	LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
    2923   00:ED7D  A6                  	AND	(HL)
    2924   00:ED7E  CA 8F ED            	JP	Z,GTNEXT2	;if zero, we must read in next extent.
    2925   00:ED81  C3 AD ED            	JP	GTNEXT3		;else, it is already in memory.
    2926   00:ED84  01 02 00            GTNEXT1:LD	BC,2		;Point to the 's2' byte.
    2927   00:ED87  09                  	ADD	HL,BC
    2928   00:ED88  34                  	INC	(HL)		;and bump it.
    2929   00:ED89  7E                  	LD	A,(HL)		;too many extents?
    2930   00:ED8A  E6 0F               	AND	0FH
    2931   00:ED8C  CA B7 ED            	JP	Z,GTNEXT5	;yes, set error code.
    2932   00:ED8F                      ;
    2933   00:ED8F                      ;   Get here to open the next extent.
    2934   00:ED8F                      ;
    2935   00:ED8F  0E 0F               GTNEXT2:LD	C,15		;set to check first 15 bytes of fcb.
    2936   00:ED91  CD 19 EB            	CALL	FINDFST		;find the first one.
    2937   00:ED94  CD F6 E9            	CALL	CKFILPOS	;none available?
    2938   00:ED97  C2 AD ED            	JP	NZ,GTNEXT3
    2939   00:ED9A  3A D2 F1            	LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
    2940   00:ED9D  3C                  	INC	A		;0ffh means reading (so not possible).
    2941   00:ED9E  CA B7 ED            	JP	Z,GTNEXT5	;or an error.
    2942   00:EDA1  CD 25 ED            	CALL	GETEMPTY	;we are writing, get an empty entry.
    2943   00:EDA4  CD F6 E9            	CALL	CKFILPOS	;none?
    2944   00:EDA7  CA B7 ED            	JP	Z,GTNEXT5	;error if true.
    2945   00:EDAA  C3 B0 ED            	JP	GTNEXT4		;else we are almost done.
    2946   00:EDAD  CD 5B EC            GTNEXT3:CALL	OPENIT1		;open this extent.
    2947   00:EDB0  CD BB E8            GTNEXT4:CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
    2948   00:EDB3  AF                  	XOR	A		;clear status and return.
    2949   00:EDB4  C3 01 E7            	JP	SETSTAT
    2950   00:EDB7                      ;
    2951   00:EDB7                      ;   Error in extending the file. Too many extents were needed
    2952   00:EDB7                      ; or not enough space on the disk.
    2953   00:EDB7                      ;
    2954   00:EDB7  CD 05 E7            GTNEXT5:CALL	IOERR1		;set error code, clear bit 7 of 's2'
    2955   00:EDBA  C3 79 E9            	JP	SETS2B7		;so this is not written on a close.
    2956   00:EDBD                      ;
    2957   00:EDBD                      ;   Read a sequential file.
    2958   00:EDBD                      ;
    2959   00:EDBD  3E 01               RDSEQ:	LD	A,1		;set sequential access mode.
    2960   00:EDBF  32 D4 F1            	LD	(MODE),A
    2961   00:EDC2  3E FF               RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space.
    2962   00:EDC4  32 D2 F1            	LD	(RDWRTFLG),A
    2963   00:EDC7  CD BB E8            	CALL	STRDATA		;put rec# and ext# into fcb.
    2964   00:EDCA  3A E2 F1            	LD	A,(SAVNREC)	;get next record to read.
    2965   00:EDCD  21 E0 F1            	LD	HL,SAVNXT	;get number of records in extent.
    2966   00:EDD0  BE                  	CP	(HL)		;within this extent?
    2967   00:EDD1  DA E7 ED            	JP	C,RDSEQ2
    2968   00:EDD4  FE 80               	CP	128		;no. Is this extent fully used?
    2969   00:EDD6  C2 FC ED            	JP	NZ,RDSEQ3	;no. End-of-file.
    2970   00:EDD9  CD 5B ED            	CALL	GETNEXT		;yes, open the next one.
    2971   00:EDDC  AF                  	XOR	A		;reset next record to read.
    2972   00:EDDD  32 E2 F1            	LD	(SAVNREC),A
    2973   00:EDE0  3A 45 E7            	LD	A,(STATUS)	;check on open, successful?
    2974   00:EDE3  B7                  	OR	A
    2975   00:EDE4  C2 FC ED            	JP	NZ,RDSEQ3	;no, error.
    2976   00:EDE7  CD 77 E8            RDSEQ2:	CALL	COMBLK		;ok. compute block number to read.
    2977   00:EDEA  CD 84 E8            	CALL	CHKBLK		;check it. Within bounds?
    2978   00:EDED  CA FC ED            	JP	Z,RDSEQ3	;no, error.
    2979   00:EDF0  CD 8A E8            	CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
    2980   00:EDF3  CD D1 E7            	CALL	TRKSEC1		;set the track and sector for this block #.
    2981   00:EDF6  CD B2 E7            	CALL	DOREAD		;and read it.
    2982   00:EDF9  C3 D2 E8            	JP	SETNREC		;and set the next record to be accessed.
    2983   00:EDFC                      ;
    2984   00:EDFC                      ;   Read error occured. Set status and return.
    2985   00:EDFC                      ;
    2986   00:EDFC  C3 05 E7            RDSEQ3:	JP	IOERR1
    2987   00:EDFF                      ;
    2988   00:EDFF                      ;   Write the next sequential record.
    2989   00:EDFF                      ;
    2990   00:EDFF  3E 01               WTSEQ:	LD	A,1		;set sequential access mode.
    2991   00:EE01  32 D4 F1            	LD	(MODE),A
    2992   00:EE04  3E 00               WTSEQ1:	LD	A,0		;allow an addition empty extent to be opened.
    2993   00:EE06  32 D2 F1            	LD	(RDWRTFLG),A
    2994   00:EE09  CD 55 E9            	CALL	CHKWPRT		;check write protect status.
    2995   00:EE0C  2A 43 E7            	LD	HL,(PARAMS)
    2996   00:EE0F  CD 48 E9            	CALL	CKROF1		;check for read only file, (HL) already set to fcb.
    2997   00:EE12  CD BB E8            	CALL	STRDATA		;put updated data into fcb.
    2998   00:EE15  3A E2 F1            	LD	A,(SAVNREC)	;get record number to write.
    2999   00:EE18  FE 80               	CP	128		;within range?
    3000   00:EE1A  D2 05 E7            	JP	NC,IOERR1	;no, error(?).
    3001   00:EE1D  CD 77 E8            	CALL	COMBLK		;compute block number.
    3002   00:EE20  CD 84 E8            	CALL	CHKBLK		;check number.
    3003   00:EE23  0E 00               	LD	C,0		;is there one to write to?
    3004   00:EE25  C2 6F EE            	JP	NZ,WTSEQ6	;yes, go do it.
    3005   00:EE28  CD 3E E8            	CALL	GETBLOCK	;get next block number within fcb to use.
    3006   00:EE2B  32 D6 F1            	LD	(RELBLOCK),A	;and save.
    3007   00:EE2E  01 00 00            	LD	BC,0		;start looking for space from the start
    3008   00:EE31  B7                  	OR	A		;if none allocated as yet.
    3009   00:EE32  CA 3C EE            	JP	Z,WTSEQ2
    3010   00:EE35  4F                  	LD	C,A		;extract previous block number from fcb
    3011   00:EE36  0B                  	DEC	BC		;so we can be closest to it.
    3012   00:EE37  CD 5E E8            	CALL	EXTBLK
    3013   00:EE3A  44                  	LD	B,H
    3014   00:EE3B  4D                  	LD	C,L
    3015   00:EE3C  CD BF EB            WTSEQ2:	CALL	FNDSPACE	;find the next empty block nearest number (BC).
    3016   00:EE3F  7D                  	LD	A,L		;check for a zero number.
    3017   00:EE40  B4                  	OR	H
    3018   00:EE41  C2 49 EE            	JP	NZ,WTSEQ3
    3019   00:EE44  3E 02               	LD	A,2		;no more space?
    3020   00:EE46  C3 01 E7            	JP	SETSTAT
    3021   00:EE49  22 E4 F1            WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access.
    3022   00:EE4C  EB                  	EX	DE,HL		;put block number into (DE).
    3023   00:EE4D  2A 43 E7            	LD	HL,(PARAMS)	;now we must update the fcb for this
    3024   00:EE50  01 10 00            	LD	BC,16		;newly allocated block.
    3025   00:EE53  09                  	ADD	HL,BC
    3026   00:EE54  3A DC F1            	LD	A,(BIGDISK)	;8 or 16 bit block numbers?
    3027   00:EE57  B7                  	OR	A
    3028   00:EE58  3A D6 F1            	LD	A,(RELBLOCK)	;(* update this entry *)
    3029   00:EE5B  CA 65 EE            	JP	Z,WTSEQ4	;zero means 16 bit ones.
    3030   00:EE5E  CD 65 E9            	CALL	ADDA2HL		;(HL)=(HL)+(A)
    3031   00:EE61  73                  	LD	(HL),E		;store new block number.
    3032   00:EE62  C3 6D EE            	JP	WTSEQ5
    3033   00:EE65  4F                  WTSEQ4:	LD	C,A		;compute spot in this 16 bit table.
    3034   00:EE66  06 00               	LD	B,0
    3035   00:EE68  09                  	ADD	HL,BC
    3036   00:EE69  09                  	ADD	HL,BC
    3037   00:EE6A  73                  	LD	(HL),E		;stuff block number (DE) there.
    3038   00:EE6B  23                  	INC	HL
    3039   00:EE6C  72                  	LD	(HL),D
    3040   00:EE6D  0E 02               WTSEQ5:	LD	C,2		;set (C) to indicate writing to un-used disk space.
    3041   00:EE6F  3A 45 E7            WTSEQ6:	LD	A,(STATUS)	;are we ok so far?
    3042   00:EE72  B7                  	OR	A
    3043   00:EE73  C0                  	RET	NZ
    3044   00:EE74  C5                  	PUSH	BC		;yes, save write flag for bios (register C).
    3045   00:EE75  CD 8A E8            	CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
    3046   00:EE78  3A D4 F1            	LD	A,(MODE)	;get access mode flag (1=sequential,
    3047   00:EE7B  3D                  	DEC	A		;0=random, 2=special?).
    3048   00:EE7C  3D                  	DEC	A
    3049   00:EE7D  C2 BC EE            	JP	NZ,WTSEQ9
    3050   00:EE80                      ;
    3051   00:EE80                      ;   Special random i/o from function #40. Maybe for M/PM, but the
    3052   00:EE80                      ; current block, if it has not been written to, will be zeroed
    3053   00:EE80                      ; out and then written (reason?).
    3054   00:EE80                      ;
    3055   00:EE80  C1                  	POP	BC
    3056   00:EE81  C5                  	PUSH	BC
    3057   00:EE82  79                  	LD	A,C		;get write status flag (2=writing unused space).
    3058   00:EE83  3D                  	DEC	A
    3059   00:EE84  3D                  	DEC	A
    3060   00:EE85  C2 BC EE            	JP	NZ,WTSEQ9
    3061   00:EE88  E5                  	PUSH	HL
    3062   00:EE89  2A B8 F1            	LD	HL,(DIRBUF)	;zero out the directory buffer.
    3063   00:EE8C  57                  	LD	D,A		;note that (A) is zero here.
    3064   00:EE8D  77                  WTSEQ7:	LD	(HL),A
    3065   00:EE8E  23                  	INC	HL
    3066   00:EE8F  14                  	INC	D		;do 128 bytes.
    3067   00:EE90  F2 8D EE            	JP	P,WTSEQ7
    3068   00:EE93  CD E1 E9            	CALL	DIRDMA		;tell the bios the dma address for directory access.
    3069   00:EE96  2A E6 F1            	LD	HL,(LOGSECT)	;get sector that starts current block.
    3070   00:EE99  0E 02               	LD	C,2		;set 'writing to unused space' flag.
    3071   00:EE9B  22 E4 F1            WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write.
    3072   00:EE9E  C5                  	PUSH	BC
    3073   00:EE9F  CD D1 E7            	CALL	TRKSEC1		;determine its track and sector numbers.
    3074   00:EEA2  C1                  	POP	BC
    3075   00:EEA3  CD B8 E7            	CALL	DOWRITE		;now write out 128 bytes of zeros.
    3076   00:EEA6  2A E4 F1            	LD	HL,(BLKNMBR)	;get sector number.
    3077   00:EEA9  0E 00               	LD	C,0		;set normal write flag.
    3078   00:EEAB  3A C3 F1            	LD	A,(BLKMASK)	;determine if we have written the entire
    3079   00:EEAE  47                  	LD	B,A		;physical block.
    3080   00:EEAF  A5                  	AND	L
    3081   00:EEB0  B8                  	CP	B
    3082   00:EEB1  23                  	INC	HL		;prepare for the next one.
    3083   00:EEB2  C2 9B EE            	JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written.
    3084   00:EEB5  E1                  	POP	HL		;reset next sector number.
    3085   00:EEB6  22 E4 F1            	LD	(BLKNMBR),HL
    3086   00:EEB9  CD DB E9            	CALL	DEFDMA		;and reset dma address.
    3087   00:EEBC                      ;
    3088   00:EEBC                      ;   Normal disk write. Set the desired track and sector then
    3089   00:EEBC                      ; do the actual write.
    3090   00:EEBC                      ;
    3091   00:EEBC  CD D1 E7            WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write.
    3092   00:EEBF  C1                  	POP	BC		;get write status flag.
    3093   00:EEC0  C5                  	PUSH	BC
    3094   00:EEC1  CD B8 E7            	CALL	DOWRITE		;and write this out.
    3095   00:EEC4  C1                  	POP	BC
    3096   00:EEC5  3A E2 F1            	LD	A,(SAVNREC)	;get number of records in file.
    3097   00:EEC8  21 E0 F1            	LD	HL,SAVNXT	;get last record written.
    3098   00:EECB  BE                  	CP	(HL)
    3099   00:EECC  DA D3 EE            	JP	C,WTSEQ10
    3100   00:EECF  77                  	LD	(HL),A		;we have to update record count.
    3101   00:EED0  34                  	INC	(HL)
    3102   00:EED1  0E 02               	LD	C,2
    3103   00:EED3                      ;
    3104   00:EED3                      ;*   This area has been patched to correct disk update problem
    3105   00:EED3                      ;* when using blocking and de-blocking in the BIOS.
    3106   00:EED3                      ;
    3107   00:EED3  00                  WTSEQ10:NOP			;was 'dcr c'
    3108   00:EED4  00                  	NOP			;was 'dcr c'
    3109   00:EED5  21 00 00            	LD	HL,0		;was 'jnz wtseq99'
    3110   00:EED8                      ;
    3111   00:EED8                      ; *   End of patch.
    3112   00:EED8                      ;
    3113   00:EED8  F5                  	PUSH	AF
    3114   00:EED9  CD 6A E9            	CALL	GETS2		;set 'extent written to' flag.
    3115   00:EEDC  E6 7F               	AND	7FH		;(* clear bit 7 *)
    3116   00:EEDE  77                  	LD	(HL),A
    3117   00:EEDF  F1                  	POP	AF		;get record count for this extent.
    3118   00:EEE0  FE 7F               WTSEQ99:CP	127		;is it full?
    3119   00:EEE2  C2 01 EF            	JP	NZ,WTSEQ12
    3120   00:EEE5  3A D4 F1            	LD	A,(MODE)	;yes, are we in sequential mode?
    3121   00:EEE8  FE 01               	CP	1
    3122   00:EEEA  C2 01 EF            	JP	NZ,WTSEQ12
    3123   00:EEED  CD D2 E8            	CALL	SETNREC		;yes, set next record number.
    3124   00:EEF0  CD 5B ED            	CALL	GETNEXT		;and get next empty space in directory.
    3125   00:EEF3  21 45 E7            	LD	HL,STATUS	;ok?
    3126   00:EEF6  7E                  	LD	A,(HL)
    3127   00:EEF7  B7                  	OR	A
    3128   00:EEF8  C2 FF EE            	JP	NZ,WTSEQ11
    3129   00:EEFB  3D                  	DEC	A		;yes, set record count to -1.
    3130   00:EEFC  32 E2 F1            	LD	(SAVNREC),A
    3131   00:EEFF  36 00               WTSEQ11:LD	(HL),0		;clear status.
    3132   00:EF01  C3 D2 E8            WTSEQ12:JP	SETNREC		;set next record to access.
    3133   00:EF04                      ;
    3134   00:EF04                      ;   For random i/o, set the fcb for the desired record number
    3135   00:EF04                      ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
    3136   00:EF04                      ; used as follows:
    3137   00:EF04                      ;
    3138   00:EF04                      ;       fcb+35            fcb+34            fcb+33
    3139   00:EF04                      ;  |     'r-2'      |      'r-1'      |      'r-0'     |
    3140   00:EF04                      ;  |7             0 | 7             0 | 7             0|
    3141   00:EF04                      ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
    3142   00:EF04                      ;  |    overflow   | | extra |  extent   |   record #  |
    3143   00:EF04                      ;  | ______________| |_extent|__number___|_____________|
    3144   00:EF04                      ;                     also 's2'
    3145   00:EF04                      ;
    3146   00:EF04                      ;   On entry, register (C) contains 0ffh if this is a read
    3147   00:EF04                      ; and thus we can not access unwritten disk space. Otherwise,
    3148   00:EF04                      ; another extent will be opened (for writing) if required.
    3149   00:EF04                      ;
    3150   00:EF04  AF                  POSITION: XOR	A		;set random i/o flag.
    3151   00:EF05  32 D4 F1            	LD	(MODE),A
    3152   00:EF08                      ;
    3153   00:EF08                      ;   Special entry (function #40). M/PM ?
    3154   00:EF08                      ;
    3155   00:EF08  C5                  POSITN1:PUSH	BC		;save read/write flag.
    3156   00:EF09  2A 43 E7            	LD	HL,(PARAMS)	;get address of fcb.
    3157   00:EF0C  EB                  	EX	DE,HL
    3158   00:EF0D  21 21 00            	LD	HL,33		;now get byte 'r0'.
    3159   00:EF10  19                  	ADD	HL,DE
    3160   00:EF11  7E                  	LD	A,(HL)
    3161   00:EF12  E6 7F               	AND	7FH		;keep bits 0-6 for the record number to access.
    3162   00:EF14  F5                  	PUSH	AF
    3163   00:EF15  7E                  	LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
    3164   00:EF16  17                  	RLA	
    3165   00:EF17  23                  	INC	HL
    3166   00:EF18  7E                  	LD	A,(HL)
    3167   00:EF19  17                  	RLA	
    3168   00:EF1A  E6 1F               	AND	1FH		;and save this in bits 0-4 of (C).
    3169   00:EF1C  4F                  	LD	C,A		;this is the extent byte.
    3170   00:EF1D  7E                  	LD	A,(HL)		;now get the extra extent byte.
    3171   00:EF1E  1F                  	RRA	
    3172   00:EF1F  1F                  	RRA	
    3173   00:EF20  1F                  	RRA	
    3174   00:EF21  1F                  	RRA	
    3175   00:EF22  E6 0F               	AND	0FH
    3176   00:EF24  47                  	LD	B,A		;and save it in (B).
    3177   00:EF25  F1                  	POP	AF		;get record number back to (A).
    3178   00:EF26  23                  	INC	HL		;check overflow byte 'r2'.
    3179   00:EF27  6E                  	LD	L,(HL)
    3180   00:EF28  2C                  	INC	L
    3181   00:EF29  2D                  	DEC	L
    3182   00:EF2A  2E 06               	LD	L,6		;prepare for error.
    3183   00:EF2C  C2 8C EF            	JP	NZ,POSITN5	;out of disk space error.
    3184   00:EF2F  21 20 00            	LD	HL,32		;store record number into fcb.
    3185   00:EF32  19                  	ADD	HL,DE
    3186   00:EF33  77                  	LD	(HL),A
    3187   00:EF34  21 0C 00            	LD	HL,12		;and now check the extent byte.
    3188   00:EF37  19                  	ADD	HL,DE
    3189   00:EF38  79                  	LD	A,C
    3190   00:EF39  96                  	SUB	(HL)		;same extent as before?
    3191   00:EF3A  C2 48 EF            	JP	NZ,POSITN2
    3192   00:EF3D  21 0E 00            	LD	HL,14		;yes, check extra extent byte 's2' also.
    3193   00:EF40  19                  	ADD	HL,DE
    3194   00:EF41  78                  	LD	A,B
    3195   00:EF42  96                  	SUB	(HL)
    3196   00:EF43  E6 7F               	AND	7FH
    3197   00:EF45  CA 80 EF            	JP	Z,POSITN3	;same, we are almost done then.
    3198   00:EF48                      ;
    3199   00:EF48                      ;  Get here when another extent is required.
    3200   00:EF48                      ;
    3201   00:EF48  C5                  POSITN2:PUSH	BC
    3202   00:EF49  D5                  	PUSH	DE
    3203   00:EF4A  CD A3 EC            	CALL	CLOSEIT		;close current extent.
    3204   00:EF4D  D1                  	POP	DE
    3205   00:EF4E  C1                  	POP	BC
    3206   00:EF4F  2E 03               	LD	L,3		;prepare for error.
    3207   00:EF51  3A 45 E7            	LD	A,(STATUS)
    3208   00:EF54  3C                  	INC	A
    3209   00:EF55  CA 85 EF            	JP	Z,POSITN4	;close error.
    3210   00:EF58  21 0C 00            	LD	HL,12		;put desired extent into fcb now.
    3211   00:EF5B  19                  	ADD	HL,DE
    3212   00:EF5C  71                  	LD	(HL),C
    3213   00:EF5D  21 0E 00            	LD	HL,14		;and store extra extent byte 's2'.
    3214   00:EF60  19                  	ADD	HL,DE
    3215   00:EF61  70                  	LD	(HL),B
    3216   00:EF62  CD 52 EC            	CALL	OPENIT		;try and get this extent.
    3217   00:EF65  3A 45 E7            	LD	A,(STATUS)	;was it there?
    3218   00:EF68  3C                  	INC	A
    3219   00:EF69  C2 80 EF            	JP	NZ,POSITN3
    3220   00:EF6C  C1                  	POP	BC		;no. can we create a new one (writing?).
    3221   00:EF6D  C5                  	PUSH	BC
    3222   00:EF6E  2E 04               	LD	L,4		;prepare for error.
    3223   00:EF70  0C                  	INC	C
    3224   00:EF71  CA 85 EF            	JP	Z,POSITN4	;nope, reading unwritten space error.
    3225   00:EF74  CD 25 ED            	CALL	GETEMPTY	;yes we can, try to find space.
    3226   00:EF77  2E 05               	LD	L,5		;prepare for error.
    3227   00:EF79  3A 45 E7            	LD	A,(STATUS)
    3228   00:EF7C  3C                  	INC	A
    3229   00:EF7D  CA 85 EF            	JP	Z,POSITN4	;out of space?
    3230   00:EF80                      ;
    3231   00:EF80                      ;   Normal return location. Clear error code and return.
    3232   00:EF80                      ;
    3233   00:EF80  C1                  POSITN3:POP	BC		;restore stack.
    3234   00:EF81  AF                  	XOR	A		;and clear error code byte.
    3235   00:EF82  C3 01 E7            	JP	SETSTAT
    3236   00:EF85                      ;
    3237   00:EF85                      ;   Error. Set the 's2' byte to indicate this (why?).
    3238   00:EF85                      ;
    3239   00:EF85  E5                  POSITN4:PUSH	HL
    3240   00:EF86  CD 6A E9            	CALL	GETS2
    3241   00:EF89  36 C0               	LD	(HL),0C0H
    3242   00:EF8B  E1                  	POP	HL
    3243   00:EF8C                      ;
    3244   00:EF8C                      ;   Return with error code (presently in L).
    3245   00:EF8C                      ;
    3246   00:EF8C  C1                  POSITN5:POP	BC
    3247   00:EF8D  7D                  	LD	A,L		;get error code.
    3248   00:EF8E  32 45 E7            	LD	(STATUS),A
    3249   00:EF91  C3 79 E9            	JP	SETS2B7
    3250   00:EF94                      ;
    3251   00:EF94                      ;   Read a random record.
    3252   00:EF94                      ;
    3253   00:EF94  0E FF               READRAN:LD	C,0FFH		;set 'read' status.
    3254   00:EF96  CD 04 EF            	CALL	POSITION	;position the file to proper record.
    3255   00:EF99  CC C2 ED            	CALL	Z,RDSEQ1	;and read it as usual (if no errors).
    3256   00:EF9C  C9                  	RET	
    3257   00:EF9D                      ;
    3258   00:EF9D                      ;   Write to a random record.
    3259   00:EF9D                      ;
    3260   00:EF9D  0E 00               WRITERAN: LD	C,0		;set 'writing' flag.
    3261   00:EF9F  CD 04 EF            	CALL	POSITION	;position the file to proper record.
    3262   00:EFA2  CC 04 EE            	CALL	Z,WTSEQ1	;and write as usual (if no errors).
    3263   00:EFA5  C9                  	RET	
    3264   00:EFA6                      ;
    3265   00:EFA6                      ;   Compute the random record number. Enter with (HL) pointing
    3266   00:EFA6                      ; to a fcb an (DE) contains a relative location of a record
    3267   00:EFA6                      ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
    3268   00:EFA6                      ; byte, and (A) the 'r2' byte.
    3269   00:EFA6                      ;
    3270   00:EFA6                      ;   On return, the zero flag is set if the record is within
    3271   00:EFA6                      ; bounds. Otherwise, an overflow occured.
    3272   00:EFA6                      ;
    3273   00:EFA6  EB                  COMPRAND: EX	DE,HL		;save fcb pointer in (DE).
    3274   00:EFA7  19                  	ADD	HL,DE		;compute relative position of record #.
    3275   00:EFA8  4E                  	LD	C,(HL)		;get record number into (BC).
    3276   00:EFA9  06 00               	LD	B,0
    3277   00:EFAB  21 0C 00            	LD	HL,12		;now get extent.
    3278   00:EFAE  19                  	ADD	HL,DE
    3279   00:EFAF  7E                  	LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
    3280   00:EFB0  0F                  	RRCA			;move lower bit into bit 7.
    3281   00:EFB1  E6 80               	AND	80H		;and ignore all other bits.
    3282   00:EFB3  81                  	ADD	A,C		;add to our record number.
    3283   00:EFB4  4F                  	LD	C,A
    3284   00:EFB5  3E 00               	LD	A,0		;take care of any carry.
    3285   00:EFB7  88                  	ADC	A,B
    3286   00:EFB8  47                  	LD	B,A
    3287   00:EFB9  7E                  	LD	A,(HL)		;now get the upper bits of extent into
    3288   00:EFBA  0F                  	RRCA			;bit positions 0-3.
    3289   00:EFBB  E6 0F               	AND	0FH		;and ignore all others.
    3290   00:EFBD  80                  	ADD	A,B		;add this in to 'r1' byte.
    3291   00:EFBE  47                  	LD	B,A
    3292   00:EFBF  21 0E 00            	LD	HL,14		;get the 's2' byte (extra extent).
    3293   00:EFC2  19                  	ADD	HL,DE
    3294   00:EFC3  7E                  	LD	A,(HL)
    3295   00:EFC4  87                  	ADD	A,A		;and shift it left 4 bits (bits 4-7).
    3296   00:EFC5  87                  	ADD	A,A
    3297   00:EFC6  87                  	ADD	A,A
    3298   00:EFC7  87                  	ADD	A,A
    3299   00:EFC8  F5                  	PUSH	AF		;save carry flag (bit 0 of flag byte).
    3300   00:EFC9  80                  	ADD	A,B		;now add extra extent into 'r1'.
    3301   00:EFCA  47                  	LD	B,A
    3302   00:EFCB  F5                  	PUSH	AF		;and save carry (overflow byte 'r2').
    3303   00:EFCC  E1                  	POP	HL		;bit 0 of (L) is the overflow indicator.
    3304   00:EFCD  7D                  	LD	A,L
    3305   00:EFCE  E1                  	POP	HL		;and same for first carry flag.
    3306   00:EFCF  B5                  	OR	L		;either one of these set?
    3307   00:EFD0  E6 01               	AND	01H		;only check the carry flags.
    3308   00:EFD2  C9                  	RET	
    3309   00:EFD3                      ;
    3310   00:EFD3                      ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
    3311   00:EFD3                      ; reflect the last record used for a random (or other) file.
    3312   00:EFD3                      ; This reads the directory and looks at all extents computing
    3313   00:EFD3                      ; the largerst record number for each and keeping the maximum
    3314   00:EFD3                      ; value only. Then 'r0', 'r1', and 'r2' will reflect this
    3315   00:EFD3                      ; maximum record number. This is used to compute the space used
    3316   00:EFD3                      ; by a random file.
    3317   00:EFD3                      ;
    3318   00:EFD3  0E 0C               RANSIZE:LD	C,12		;look thru directory for first entry with
    3319   00:EFD5  CD 19 EB            	CALL	FINDFST		;this name.
    3320   00:EFD8  2A 43 E7            	LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
    3321   00:EFDB  11 21 00            	LD	DE,33
    3322   00:EFDE  19                  	ADD	HL,DE
    3323   00:EFDF  E5                  	PUSH	HL
    3324   00:EFE0  72                  	LD	(HL),D		;note that (D)=0.
    3325   00:EFE1  23                  	INC	HL
    3326   00:EFE2  72                  	LD	(HL),D
    3327   00:EFE3  23                  	INC	HL
    3328   00:EFE4  72                  	LD	(HL),D
    3329   00:EFE5  CD F6 E9            RANSIZ1:CALL	CKFILPOS	;is there an extent to process?
    3330   00:EFE8  CA 0B F0            	JP	Z,RANSIZ3	;no, we are done.
    3331   00:EFEB  CD 5F E9            	CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
    3332   00:EFEE  11 0F 00            	LD	DE,15		;point to last record in extent.
    3333   00:EFF1  CD A6 EF            	CALL	COMPRAND	;and compute random parameters.
    3334   00:EFF4  E1                  	POP	HL
    3335   00:EFF5  E5                  	PUSH	HL		;now check these values against those
    3336   00:EFF6  5F                  	LD	E,A		;already in fcb.
    3337   00:EFF7  79                  	LD	A,C		;the carry flag will be set if those
    3338   00:EFF8  96                  	SUB	(HL)		;in the fcb represent a larger size than
    3339   00:EFF9  23                  	INC	HL		;this extent does.
    3340   00:EFFA  78                  	LD	A,B
    3341   00:EFFB                      	;SBC	A,M
    3342   00:EFFB  23                  	INC	HL
    3343   00:EFFC  7B                  	LD	A,E
    3344   00:EFFD                      	;SBC	A,M
    3345   00:EFFD  DA 05 F0            	JP	C,RANSIZ2
    3346   00:F000  73                  	LD	(HL),E		;we found a larger (in size) extent.
    3347   00:F001  2B                  	DEC	HL		;stuff these values into fcb.
    3348   00:F002  70                  	LD	(HL),B
    3349   00:F003  2B                  	DEC	HL
    3350   00:F004  71                  	LD	(HL),C
    3351   00:F005  CD 2E EB            RANSIZ2:CALL	FINDNXT		;now get the next extent.
    3352   00:F008  C3 E5 EF            	JP	RANSIZ1		;continue til all done.
    3353   00:F00B  E1                  RANSIZ3:POP	HL		;we are done, restore the stack and
    3354   00:F00C  C9                  	RET			;return.
    3355   00:F00D                      ;
    3356   00:F00D                      ;   Function to return the random record position of a given
    3357   00:F00D                      ; file which has been read in sequential mode up to now.
    3358   00:F00D                      ;
    3359   00:F00D  2A 43 E7            SETRAN:	LD	HL,(PARAMS)	;point to fcb.
    3360   00:F010  11 20 00            	LD	DE,32		;and to last used record.
    3361   00:F013  CD A6 EF            	CALL	COMPRAND	;compute random position.
    3362   00:F016  21 21 00            	LD	HL,33		;now stuff these values into fcb.
    3363   00:F019  19                  	ADD	HL,DE
    3364   00:F01A  71                  	LD	(HL),C		;move 'r0'.
    3365   00:F01B  23                  	INC	HL
    3366   00:F01C  70                  	LD	(HL),B		;and 'r1'.
    3367   00:F01D  23                  	INC	HL
    3368   00:F01E  77                  	LD	(HL),A		;and lastly 'r2'.
    3369   00:F01F  C9                  	RET	
    3370   00:F020                      ;
    3371   00:F020                      ;   This routine select the drive specified in (ACTIVE) and
    3372   00:F020                      ; update the login vector and bitmap table if this drive was
    3373   00:F020                      ; not already active.
    3374   00:F020                      ;
    3375   00:F020  2A AE F1            LOGINDRV: LD	HL,(LOGIN)	;get the login vector.
    3376   00:F023  3A 42 E7            	LD	A,(ACTIVE)	;get the default drive.
    3377   00:F026  4F                  	LD	C,A
    3378   00:F027  CD EA E8            	CALL	SHIFTR		;position active bit for this drive
    3379   00:F02A  E5                  	PUSH	HL		;into bit 0.
    3380   00:F02B  EB                  	EX	DE,HL
    3381   00:F02C  CD 59 E7            	CALL	SELECT		;select this drive.
    3382   00:F02F  E1                  	POP	HL
    3383   00:F030  CC 47 E7            	CALL	Z,SLCTERR	;valid drive?
    3384   00:F033  7D                  	LD	A,L		;is this a newly activated drive?
    3385   00:F034  1F                  	RRA	
    3386   00:F035  D8                  	RET	C
    3387   00:F036  2A AE F1            	LD	HL,(LOGIN)	;yes, update the login vector.
    3388   00:F039  4D                  	LD	C,L
    3389   00:F03A  44                  	LD	B,H
    3390   00:F03B  CD 0C E9            	CALL	SETBIT
    3391   00:F03E  22 AE F1            	LD	(LOGIN),HL	;and save.
    3392   00:F041  C3 A4 EA            	JP	BITMAP		;now update the bitmap.
    3393   00:F044                      ;
    3394   00:F044                      ;   Function to set the active disk number.
    3395   00:F044                      ;
    3396   00:F044  3A D5 F1            SETDSK:	LD	A,(EPARAM)	;get parameter passed and see if this
    3397   00:F047  21 42 E7            	LD	HL,ACTIVE	;represents a change in drives.
    3398   00:F04A  BE                  	CP	(HL)
    3399   00:F04B  C8                  	RET	Z
    3400   00:F04C  77                  	LD	(HL),A		;yes it does, log it in.
    3401   00:F04D  C3 20 F0            	JP	LOGINDRV
    3402   00:F050                      ;
    3403   00:F050                      ;   This is the 'auto disk select' routine. The firsst byte
    3404   00:F050                      ; of the fcb is examined for a drive specification. If non
    3405   00:F050                      ; zero then the drive will be selected and loged in.
    3406   00:F050                      ;
    3407   00:F050  3E FF               AUTOSEL:LD	A,0FFH		;say 'auto-select activated'.
    3408   00:F052  32 DD F1            	LD	(AUTO),A
    3409   00:F055  2A 43 E7            	LD	HL,(PARAMS)	;get drive specified.
    3410   00:F058  7E                  	LD	A,(HL)
    3411   00:F059  E6 1F               	AND	1FH		;look at lower 5 bits.
    3412   00:F05B  3D                  	DEC	A		;adjust for (1=A, 2=B) etc.
    3413   00:F05C  32 D5 F1            	LD	(EPARAM),A	;and save for the select routine.
    3414   00:F05F  FE 1E               	CP	1EH		;check for 'no change' condition.
    3415   00:F061  D2 74 F0            	JP	NC,AUTOSL1	;yes, don't change.
    3416   00:F064  3A 42 E7            	LD	A,(ACTIVE)	;we must change, save currently active
    3417   00:F067  32 DE F1            	LD	(OLDDRV),A	;drive.
    3418   00:F06A  7E                  	LD	A,(HL)		;and save first byte of fcb also.
    3419   00:F06B  32 DF F1            	LD	(AUTOFLAG),A	;this must be non-zero.
    3420   00:F06E  E6 E0               	AND	0E0H		;whats this for (bits 6,7 are used for
    3421   00:F070  77                  	LD	(HL),A		;something)?
    3422   00:F071  CD 44 F0            	CALL	SETDSK		;select and log in this drive.
    3423   00:F074  3A 41 E7            AUTOSL1:LD	A,(USERNO)	;move user number into fcb.
    3424   00:F077  2A 43 E7            	LD	HL,(PARAMS)	;(* upper half of first byte *)
    3425   00:F07A  B6                  	OR	(HL)
    3426   00:F07B  77                  	LD	(HL),A
    3427   00:F07C  C9                  	RET			;and return (all done).
    3428   00:F07D                      ;
    3429   00:F07D                      ;   Function to return the current cp/m version number.
    3430   00:F07D                      ;
    3431   00:F07D  3E 22               GETVER:	LD	A,022H		;version 2.2
    3432   00:F07F  C3 01 E7            	JP	SETSTAT
    3433   00:F082                      ;
    3434   00:F082                      ;   Function to reset the disk system.
    3435   00:F082                      ;
    3436   00:F082  21 00 00            RSTDSK:	LD	HL,0		;clear write protect status and log
    3437   00:F085  22 AC F1            	LD	(WRTPRT),HL	;in vector.
    3438   00:F088  22 AE F1            	LD	(LOGIN),HL
    3439   00:F08B  AF                  	XOR	A		;select drive 'A'.
    3440   00:F08C  32 42 E7            	LD	(ACTIVE),A
    3441   00:F08F  21 80 00            	LD	HL,TBUFF	;setup default dma address.
    3442   00:F092  22 B0 F1            	LD	(USERDMA),HL
    3443   00:F095  CD DB E9            	CALL	DEFDMA
    3444   00:F098  C3 20 F0            	JP	LOGINDRV	;now log in drive 'A'.
    3445   00:F09B                      ;
    3446   00:F09B                      ;   Function to open a specified file.
    3447   00:F09B                      ;
    3448   00:F09B  CD 73 E9            OPENFIL:CALL	CLEARS2		;clear 's2' byte.
    3449   00:F09E  CD 50 F0            	CALL	AUTOSEL		;select proper disk.
    3450   00:F0A1  C3 52 EC            	JP	OPENIT		;and open the file.
    3451   00:F0A4                      ;
    3452   00:F0A4                      ;   Function to close a specified file.
    3453   00:F0A4                      ;
    3454   00:F0A4  CD 50 F0            CLOSEFIL: CALL	AUTOSEL		;select proper disk.
    3455   00:F0A7  C3 A3 EC            	JP	CLOSEIT		;and close the file.
    3456   00:F0AA                      ;
    3457   00:F0AA                      ;   Function to return the first occurence of a specified file
    3458   00:F0AA                      ; name. If the first byte of the fcb is '?' then the name will
    3459   00:F0AA                      ; not be checked (get the first entry no matter what).
    3460   00:F0AA                      ;
    3461   00:F0AA  0E 00               GETFST:	LD	C,0		;prepare for special search.
    3462   00:F0AC  EB                  	EX	DE,HL
    3463   00:F0AD  7E                  	LD	A,(HL)		;is first byte a '?'?
    3464   00:F0AE  FE 3F               	CP	'?'
    3465   00:F0B0  CA C1 F0            	JP	Z,GETFST1	;yes, just get very first entry (zero length match).
    3466   00:F0B3  CD A6 E8            	CALL	SETEXT		;get the extension byte from fcb.
    3467   00:F0B6  7E                  	LD	A,(HL)		;is it '?'? if yes, then we want
    3468   00:F0B7  FE 3F               	CP	'?'		;an entry with a specific 's2' byte.
    3469   00:F0B9  C4 73 E9            	CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte.
    3470   00:F0BC  CD 50 F0            	CALL	AUTOSEL		;select proper drive.
    3471   00:F0BF  0E 0F               	LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded).
    3472   00:F0C1  CD 19 EB            GETFST1:CALL	FINDFST		;find an entry and then move it into
    3473   00:F0C4  C3 EA E9            	JP	MOVEDIR		;the users dma space.
    3474   00:F0C7                      ;
    3475   00:F0C7                      ;   Function to return the next occurence of a file name.
    3476   00:F0C7                      ;
    3477   00:F0C7  2A D8 F1            GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no
    3478   00:F0CA  22 43 E7            	LD	(PARAMS),HL	;other dbos calls are allowed.
    3479   00:F0CD  CD 50 F0            	CALL	AUTOSEL		;no error will be returned, but the
    3480   00:F0D0  CD 2E EB            	CALL	FINDNXT		;results will be wrong.
    3481   00:F0D3  C3 EA E9            	JP	MOVEDIR
    3482   00:F0D6                      ;
    3483   00:F0D6                      ;   Function to delete a file by name.
    3484   00:F0D6                      ;
    3485   00:F0D6  CD 50 F0            DELFILE:CALL	AUTOSEL		;select proper drive.
    3486   00:F0D9  CD 9D EB            	CALL	ERAFILE		;erase the file.
    3487   00:F0DC  C3 02 EB            	JP	STSTATUS	;set status and return.
    3488   00:F0DF                      ;
    3489   00:F0DF                      ;   Function to execute a sequential read of the specified
    3490   00:F0DF                      ; record number.
    3491   00:F0DF                      ;
    3492   00:F0DF  CD 50 F0            READSEQ:CALL	AUTOSEL		;select proper drive then read.
    3493   00:F0E2  C3 BD ED            	JP	RDSEQ
    3494   00:F0E5                      ;
    3495   00:F0E5                      ;   Function to write the net sequential record.
    3496   00:F0E5                      ;
    3497   00:F0E5  CD 50 F0            WRTSEQ:	CALL	AUTOSEL		;select proper drive then write.
    3498   00:F0E8  C3 FF ED            	JP	WTSEQ
    3499   00:F0EB                      ;
    3500   00:F0EB                      ;   Create a file function.
    3501   00:F0EB                      ;
    3502   00:F0EB  CD 73 E9            FCREATE:CALL	CLEARS2		;clear the 's2' byte on all creates.
    3503   00:F0EE  CD 50 F0            	CALL	AUTOSEL		;select proper drive and get the next
    3504   00:F0F1  C3 25 ED            	JP	GETEMPTY	;empty directory space.
    3505   00:F0F4                      ;
    3506   00:F0F4                      ;   Function to rename a file.
    3507   00:F0F4                      ;
    3508   00:F0F4  CD 50 F0            RENFILE:CALL	AUTOSEL		;select proper drive and then switch
    3509   00:F0F7  CD 17 EC            	CALL	CHGNAMES	;file names.
    3510   00:F0FA  C3 02 EB            	JP	STSTATUS
    3511   00:F0FD                      ;
    3512   00:F0FD                      ;   Function to return the login vector.
    3513   00:F0FD                      ;
    3514   00:F0FD  2A AE F1            GETLOG:	LD	HL,(LOGIN)
    3515   00:F100  C3 28 F1            	JP	GETPRM1
    3516   00:F103                      ;
    3517   00:F103                      ;   Function to return the current disk assignment.
    3518   00:F103                      ;
    3519   00:F103  3A 42 E7            GETCRNT:LD	A,(ACTIVE)
    3520   00:F106  C3 01 E7            	JP	SETSTAT
    3521   00:F109                      ;
    3522   00:F109                      ;   Function to set the dma address.
    3523   00:F109                      ;
    3524   00:F109  EB                  PUTDMA:	EX	DE,HL
    3525   00:F10A  22 B0 F1            	LD	(USERDMA),HL	;save in our space and then get to
    3526   00:F10D  C3 DB E9            	JP	DEFDMA		;the bios with this also.
    3527   00:F110                      ;
    3528   00:F110                      ;   Function to return the allocation vector.
    3529   00:F110                      ;
    3530   00:F110  2A BE F1            GETALOC:LD	HL,(ALOCVECT)
    3531   00:F113  C3 28 F1            	JP	GETPRM1
    3532   00:F116                      ;
    3533   00:F116                      ;   Function to return the read-only status vector.
    3534   00:F116                      ;
    3535   00:F116  2A AC F1            GETROV:	LD	HL,(WRTPRT)
    3536   00:F119  C3 28 F1            	JP	GETPRM1
    3537   00:F11C                      ;
    3538   00:F11C                      ;   Function to set the file attributes (read-only, system).
    3539   00:F11C                      ;
    3540   00:F11C  CD 50 F0            SETATTR:CALL	AUTOSEL		;select proper drive then save attributes.
    3541   00:F11F  CD 3C EC            	CALL	SAVEATTR
    3542   00:F122  C3 02 EB            	JP	STSTATUS
    3543   00:F125                      ;
    3544   00:F125                      ;   Function to return the address of the disk parameter block
    3545   00:F125                      ; for the current drive.
    3546   00:F125                      ;
    3547   00:F125  2A BA F1            GETPARM:LD	HL,(DISKPB)
    3548   00:F128  22 45 E7            GETPRM1:LD	(STATUS),HL
    3549   00:F12B  C9                  	RET	
    3550   00:F12C                      ;
    3551   00:F12C                      ;   Function to get or set the user number. If (E) was (FF)
    3552   00:F12C                      ; then this is a request to return the current user number.
    3553   00:F12C                      ; Else set the user number from (E).
    3554   00:F12C                      ;
    3555   00:F12C  3A D5 F1            GETUSER:LD	A,(EPARAM)	;get parameter.
    3556   00:F12F  FE FF               	CP	0FFH		;get user number?
    3557   00:F131  C2 3A F1            	JP	NZ,SETUSER
    3558   00:F134  3A 41 E7            	LD	A,(USERNO)	;yes, just do it.
    3559   00:F137  C3 01 E7            	JP	SETSTAT
    3560   00:F13A  E6 1F               SETUSER:AND	1FH		;no, we should set it instead. keep low
    3561   00:F13C  32 41 E7            	LD	(USERNO),A	;bits (0-4) only.
    3562   00:F13F  C9                  	RET	
    3563   00:F140                      ;
    3564   00:F140                      ;   Function to read a random record from a file.
    3565   00:F140                      ;
    3566   00:F140  CD 50 F0            RDRANDOM: CALL	AUTOSEL		;select proper drive and read.
    3567   00:F143  C3 94 EF            	JP	READRAN
    3568   00:F146                      ;
    3569   00:F146                      ;   Function to compute the file size for random files.
    3570   00:F146                      ;
    3571   00:F146  CD 50 F0            WTRANDOM: CALL	AUTOSEL		;select proper drive and write.
    3572   00:F149  C3 9D EF            	JP	WRITERAN
    3573   00:F14C                      ;
    3574   00:F14C                      ;   Function to compute the size of a random file.
    3575   00:F14C                      ;
    3576   00:F14C  CD 50 F0            FILESIZE: CALL	AUTOSEL		;select proper drive and check file length
    3577   00:F14F  C3 D3 EF            	JP	RANSIZE
    3578   00:F152                      ;
    3579   00:F152                      ;   Function #37. This allows a program to log off any drives.
    3580   00:F152                      ; On entry, set (DE) to contain a word with bits set for those
    3581   00:F152                      ; drives that are to be logged off. The log-in vector and the
    3582   00:F152                      ; write protect vector will be updated. This must be a M/PM
    3583   00:F152                      ; special function.
    3584   00:F152                      ;
    3585   00:F152  2A 43 E7            LOGOFF:	LD	HL,(PARAMS)	;get drives to log off.
    3586   00:F155  7D                  	LD	A,L		;for each bit that is set, we want
    3587   00:F156  2F                  	CPL			;to clear that bit in (LOGIN)
    3588   00:F157  5F                  	LD	E,A		;and (WRTPRT).
    3589   00:F158  7C                  	LD	A,H
    3590   00:F159  2F                  	CPL	
    3591   00:F15A  2A AE F1            	LD	HL,(LOGIN)	;reset the login vector.
    3592   00:F15D  A4                  	AND	H
    3593   00:F15E  57                  	LD	D,A
    3594   00:F15F  7D                  	LD	A,L
    3595   00:F160  A3                  	AND	E
    3596   00:F161  5F                  	LD	E,A
    3597   00:F162  2A AC F1            	LD	HL,(WRTPRT)
    3598   00:F165  EB                  	EX	DE,HL
    3599   00:F166  22 AE F1            	LD	(LOGIN),HL	;and save.
    3600   00:F169  7D                  	LD	A,L		;now do the write protect vector.
    3601   00:F16A  A3                  	AND	E
    3602   00:F16B  6F                  	LD	L,A
    3603   00:F16C  7C                  	LD	A,H
    3604   00:F16D  A2                  	AND	D
    3605   00:F16E  67                  	LD	H,A
    3606   00:F16F  22 AC F1            	LD	(WRTPRT),HL	;and save. all done.
    3607   00:F172  C9                  	RET	
    3608   00:F173                      ;
    3609   00:F173                      ;   Get here to return to the user.
    3610   00:F173                      ;
    3611   00:F173  3A DD F1            GOBACK:	LD	A,(AUTO)	;was auto select activated?
    3612   00:F176  B7                  	OR	A
    3613   00:F177  CA 90 F1            	JP	Z,GOBACK1
    3614   00:F17A  2A 43 E7            	LD	HL,(PARAMS)	;yes, but was a change made?
    3615   00:F17D  36 00               	LD	(HL),0		;(* reset first byte of fcb *)
    3616   00:F17F  3A DF F1            	LD	A,(AUTOFLAG)
    3617   00:F182  B7                  	OR	A
    3618   00:F183  CA 90 F1            	JP	Z,GOBACK1
    3619   00:F186  77                  	LD	(HL),A		;yes, reset first byte properly.
    3620   00:F187  3A DE F1            	LD	A,(OLDDRV)	;and get the old drive and select it.
    3621   00:F18A  32 D5 F1            	LD	(EPARAM),A
    3622   00:F18D  CD 44 F0            	CALL	SETDSK
    3623   00:F190  2A 0F E7            GOBACK1:LD	HL,(USRSTACK)	;reset the users stack pointer.
    3624   00:F193  F9                  	LD	SP,HL
    3625   00:F194  2A 45 E7            	LD	HL,(STATUS)	;get return status.
    3626   00:F197  7D                  	LD	A,L		;force version 1.4 compatability.
    3627   00:F198  44                  	LD	B,H
    3628   00:F199  C9                  	RET			;and go back to user.
    3629   00:F19A                      ;
    3630   00:F19A                      ;   Function #40. This is a special entry to do random i/o.
    3631   00:F19A                      ; For the case where we are writing to unused disk space, this
    3632   00:F19A                      ; space will be zeroed out first. This must be a M/PM special
    3633   00:F19A                      ; purpose function, because why would any normal program even
    3634   00:F19A                      ; care about the previous contents of a sector about to be
    3635   00:F19A                      ; written over.
    3636   00:F19A                      ;
    3637   00:F19A  CD 50 F0            WTSPECL:CALL	AUTOSEL		;select proper drive.
    3638   00:F19D  3E 02               	LD	A,2		;use special write mode.
    3639   00:F19F  32 D4 F1            	LD	(MODE),A
    3640   00:F1A2  0E 00               	LD	C,0		;set write indicator.
    3641   00:F1A4  CD 08 EF            	CALL	POSITN1		;position the file.
    3642   00:F1A7  CC 04 EE            	CALL	Z,WTSEQ1	;and write (if no errors).
    3643   00:F1AA  C9                  	RET	
    3644   00:F1AB                      ;
    3645   00:F1AB                      ;**************************************************************
    3646   00:F1AB                      ;*
    3647   00:F1AB                      ;*     BDOS data storage pool.
    3648   00:F1AB                      ;*
    3649   00:F1AB                      ;**************************************************************
    3650   00:F1AB                      ;
    3651   00:F1AB  E5                  EMPTYFCB: DEFB	0E5H		;empty directory segment indicator.
    3652   00:F1AC  00 00               WRTPRT:	DEFW	0		;write protect status for all 16 drives.
    3653   00:F1AE  00 00               LOGIN:	DEFW	0		;drive active word (1 bit per drive).
    3654   00:F1B0  80 00               USERDMA:DEFW	080H		;user's dma address (defaults to 80h).
    3655   00:F1B2                      ;
    3656   00:F1B2                      ;   Scratch areas from parameter block.
    3657   00:F1B2                      ;
    3658   00:F1B2  00 00               SCRATCH1: DEFW	0		;relative position within dir segment for file (0-3).
    3659   00:F1B4  00 00               SCRATCH2: DEFW	0		;last selected track number.
    3660   00:F1B6  00 00               SCRATCH3: DEFW	0		;last selected sector number.
    3661   00:F1B8                      ;
    3662   00:F1B8                      ;   Disk storage areas from parameter block.
    3663   00:F1B8                      ;
    3664   00:F1B8  00 00               DIRBUF:	DEFW	0		;address of directory buffer to use.
    3665   00:F1BA  00 00               DISKPB:	DEFW	0		;contains address of disk parameter block.
    3666   00:F1BC  00 00               CHKVECT:DEFW	0		;address of check vector.
    3667   00:F1BE  00 00               ALOCVECT: DEFW	0		;address of allocation vector (bit map).
    3668   00:F1C0                      ;
    3669   00:F1C0                      ;   Parameter block returned from the bios.
    3670   00:F1C0                      ;
    3671   00:F1C0  00 00               SECTORS:DEFW	0		;sectors per track from bios.
    3672   00:F1C2  00                  BLKSHFT:DEFB	0		;block shift.
    3673   00:F1C3  00                  BLKMASK:DEFB	0		;block mask.
    3674   00:F1C4  00                  EXTMASK:DEFB	0		;extent mask.
    3675   00:F1C5  00 00               DSKSIZE:DEFW	0		;disk size from bios (number of blocks-1).
    3676   00:F1C7  00 00               DIRSIZE:DEFW	0		;directory size.
    3677   00:F1C9  00 00               ALLOC0:	DEFW	0		;storage for first bytes of bit map (dir space used).
    3678   00:F1CB  00 00               ALLOC1:	DEFW	0
    3679   00:F1CD  00 00               OFFSET:	DEFW	0		;first usable track number.
    3680   00:F1CF  00 00               XLATE:	DEFW	0		;sector translation table address.
    3681   00:F1D1                      ;
    3682   00:F1D1                      ;
    3683   00:F1D1  00                  CLOSEFLG: DEFB	0		;close flag (=0ffh is extent written ok).
    3684   00:F1D2  00                  RDWRTFLG: DEFB	0		;read/write flag (0ffh=read, 0=write).
    3685   00:F1D3  00                  FNDSTAT:DEFB	0		;filename found status (0=found first entry).
    3686   00:F1D4  00                  MODE:	DEFB	0		;I/o mode select (0=random, 1=sequential, 2=special random).
    3687   00:F1D5  00                  EPARAM:	DEFB	0		;storage for register (E) on entry to bdos.
    3688   00:F1D6  00                  RELBLOCK: DEFB	0		;relative position within fcb of block number written.
    3689   00:F1D7  00                  COUNTER:DEFB	0		;byte counter for directory name searches.
    3690   00:F1D8  00 00 00 00         SAVEFCB:DEFW	0,0		;save space for address of fcb (for directory searches).
    3691   00:F1DC  00                  BIGDISK:DEFB	0		;if =0 then disk is > 256 blocks long.
    3692   00:F1DD  00                  AUTO:	DEFB	0		;if non-zero, then auto select activated.
    3693   00:F1DE  00                  OLDDRV:	DEFB	0		;on auto select, storage for previous drive.
    3694   00:F1DF  00                  AUTOFLAG: DEFB	0		;if non-zero, then auto select changed drives.
    3695   00:F1E0  00                  SAVNXT:	DEFB	0		;storage for next record number to access.
    3696   00:F1E1  00                  SAVEXT:	DEFB	0		;storage for extent number of file.
    3697   00:F1E2  00 00               SAVNREC:DEFW	0		;storage for number of records in file.
    3698   00:F1E4  00 00               BLKNMBR:DEFW	0		;block number (physical sector) used within a file or logical sect
    3699   00:F1E6  00 00               LOGSECT:DEFW	0		;starting logical (128 byte) sector of block (physical sector).
    3700   00:F1E8  00                  FCBPOS:	DEFB	0		;relative position within buffer for fcb of file of interest.
    3701   00:F1E9  00 00               FILEPOS:DEFW	0		;files position within directory (0 to max entries -1).
    3702   00:F1EB                      ;
    3703   00:F1EB                      ;   Disk directory buffer checksum bytes. One for each of the
    3704   00:F1EB                      ; 16 possible drives.
    3705   00:F1EB                      ;
    3706   00:F1EB                      CKSUMTBL: DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    3706   00:F1EB  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
    3707   00:F1FB                      ;
    3708   00:F1FB                      ;   Extra space ?
    3709   00:F1FB                      ;
    3710   00:F1FB  00 00 00 00         	DEFB	0,0,0,0
    3711   00:F1FF                      ;
    3712   00:F1FF                      ;**************************************************************
    3713   00:F1FF                      ;*
    3714   00:F1FF                      ;*        B I O S   J U M P   T A B L E
    3715   00:F1FF                      ;*
    3716   00:F1FF                      ;**************************************************************
    3717   00:F1FF                      ;
    3718   00:F1FF  C3 00 00            BOOT:	JP	00H		;NOTE WE USE FAKE DESTINATIONS
    3719   00:F202  C3 03 00            WBOOT:	JP	03H
    3720   00:F205  C3 06 00            CONST:	JP	06H
    3721   00:F208  C3 09 00            CONIN:	JP	09H
    3722   00:F20B  C3 0C 00            CONOUT:	JP	0CH
    3723   00:F20E  C3 0F 00            LIST:	JP	0FH
    3724   00:F211  C3 12 00            PUNCH:	JP	12H
    3725   00:F214  C3 15 00            READER:	JP	15H
    3726   00:F217  C3 18 00            HOME:	JP	18H
    3727   00:F21A  C3 1B 00            SELDSK:	JP	1BH
    3728   00:F21D  C3 1E 00            SETTRK:	JP	1EH
    3729   00:F220  C3 21 00            SETSEC:	JP	21H
    3730   00:F223  C3 24 00            SETDMA:	JP	24H
    3731   00:F226  C3 27 00            READ:	JP	27H
    3732   00:F229  C3 2A 00            WRITE:	JP	2AH
    3733   00:F22C  C3 2D 00            PRSTAT:	JP	2DH
    3734   00:F22F  C3 30 00            SECTRN:	JP	30H
    3735   00:F232                      ;
    3736   00:F232                      ;*
    3737   00:F232                      ;******************   E N D   O F   C P / M   *****************
    3738   00:F232                      ;*
    3739   00:F232                      

    LABELS
-------------------------------------------------
00:0000003E   MEM
00:00000003   IOBYTE
00:00000004   TDRIVE
00:00000005   ENTRY
00:0000005C   TFCB
00:00000080   TBUFF
00:00008000   TBASE
00:00000003   CNTRLC
00:00000005   CNTRLE
00:00000008   BS
00:00000009   TAB
00:0000000A   LF
00:0000000C X FF
00:0000000D   CR
00:00000010   CNTRLP
00:00000012   CNTRLR
00:00000013   CNTRLS
00:00000015   CNTRLU
00:00000018   CNTRLX
00:0000001A   CNTRLZ
00:0000007F   DEL
00:0000DC00   CBASE
00:0000DC06   INBUFF
00:0000DC88   INPOINT
00:0000DC8A   NAMEPNT
00:0000DC8C   PRINT
00:0000DC92   PRINTB
00:0000DC98   CRLF
00:0000DCA2   SPACE
00:0000DCA7   PLINE
00:0000DCAC   PLINE2
00:0000DCB8   RESDSK
00:0000DCBD   DSKSEL
00:0000DCC3   ENTRY1
00:0000DCCB   OPEN
00:0000DCD0   OPENFCB
00:0000DCDA   CLOSE
00:0000DCDF   SRCHFST
00:0000DCE4   SRCHNXT
00:0000DCE9   SRCHFCB
00:0000DCEF   DELETE
00:0000DCF4   ENTRY2
00:0000DCF9   RDREC
00:0000DCFE   READFCB
00:0000DD04   WRTREC
00:0000DD09   CREATE
00:0000DD0E   RENAM
00:0000DD13   GETUSR
00:0000DD15   GETSETUC
00:0000DD1A   SETCDRV
00:0000DD29   MOVECD
00:0000DD30   UPPER
00:0000DD39   GETINP
00:0000DD96   GETINP1
00:0000DDA7   GETINP2
00:0000DDAB   GETINP3
00:0000DDBA   GETINP4
00:0000DDC2   CHKCON
00:0000DDD0   GETDSK
00:0000DDD5   STDDMA
00:0000DDD8   DMASET
00:0000DDDD   DELBATCH
00:0000DDF5   VERIFY
00:0000DDFD   VERIFY1
00:0000DE09   SYNERR
00:0000DE0F   SYNERR1
00:0000DE22   SYNERR2
00:0000DE30   CHECK
00:0000DE4F   NONBLANK
00:0000DE59   ADDHL
00:0000DE5E   CONVFST
00:0000DE60   CONVERT
00:0000DE89   CONVRT1
00:0000DE90   CONVRT2
00:0000DE96   CONVRT3
00:0000DE98   CONVRT4
00:0000DEA9   CONVRT5
00:0000DEAB   CONVRT6
00:0000DEAF   CONVRT7
00:0000DEB9   CONVRT8
00:0000DEC0   GETEXT
00:0000DEC8   GETEXT1
00:0000DED9   GETEXT2
00:0000DEDB   GETEXT3
00:0000DEDF   GETEXT4
00:0000DEE9   GETEXT5
00:0000DEF0   GETEXT6
00:0000DEF2   GETEXT7
00:0000DF01   GETEXT8
00:0000DF09   GETEXT9
00:00000006   NUMCMDS
00:0000DF10   CMDTBL
00:0000DF28   PATTRN1
00:0000DF2E   SEARCH
00:0000DF33   SEARCH1
00:0000DF3C   SEARCH2
00:0000DF4F   SEARCH3
00:0000DF54   SEARCH4
00:0000DF58   CLEARBUF
00:0000DF5C   COMMAND
00:0000DF82   CMMND1
00:0000DF98   CMMND2
00:0000DFC1   CMDADR
00:0000DFCF   HALT
00:0000DFD9   RDERROR
00:0000DFDF   RDERR
00:0000DFEA   NONE
00:0000DFF0   NOFILE
00:0000DFF8   DECODE
00:0000E008   DECODE1
00:0000E02A X DECODE2
00:0000E033   DECODE3
00:0000E03A X DECODE4
00:0000E040   MOVE3
00:0000E042   HL2DE
00:0000E04B   EXTRACT
00:0000E054   DSELECT
00:0000E066   RESETDR
00:0000E077   DIRECT
00:0000E088   DIRECT1
00:0000E08F   DIRECT2
00:0000E098   DIRECT3
00:0000E0CC   DIRECT4
00:0000E0D4   DIRECT5
00:0000E0D9   DIRECT6
00:0000E0F7   DRECT63
00:0000E0F9   DRECT65
00:0000E10E   DIRECT7
00:0000E10F   DIRECT8
00:0000E11B   DIRECT9
00:0000E11F   ERASE
00:0000E142   ERASE1
00:0000E152   YESNO
00:0000E15D   TYPE
00:0000E174   TYPE1
00:0000E177 X TYPE2
00:0000E187   TYPE3
00:0000E1A0   TYPE4
00:0000E1A7   TYPE5
00:0000E1AD   SAVE
00:0000E1D4   SAVE1
00:0000E1F1   SAVE2
00:0000E1FB   SAVE3
00:0000E201   SAVE4
00:0000E207   NOSPACE
00:0000E210   RENAME
00:0000E23F   RENAME1
00:0000E259   RENAME2
00:0000E25E X RENAME3
00:0000E26D   RENAME4
00:0000E273   RENAME5
00:0000E279   RENAME6
00:0000E282   EXISTS
00:0000E28E   USER
00:0000E2A5   UNKNOWN
00:0000E2C4   UNKWN1
00:0000E2CD X UNKWN2
00:0000E2E1   UNKWN3
00:0000E301   UNKWN4
00:0000E330   UNKWN5
00:0000E33E   UNKWN6
00:0000E343   UNKWN7
00:0000E34F   UNKWN8
00:0000E36B   UNKWN9
00:0000E371   UNKWN0
00:0000E37A   BADLOAD
00:0000E383   COMFILE
00:0000E386   GETBACK
00:0000E389   GETBACK1
00:0000FFFF   CCPSTACK
00:0000E3AB   BATCH
00:0000E3AC   BATCHFCB
00:0000E3CD   FCB
00:0000E3EE   RTNCODE
00:0000E3EF   CDRIVE
00:0000E3F0   CHGDRV
00:0000E3F1   NBYTES
00:0000E400   PATTRN2
00:0000E406 X FBASE
00:0000E409   BADSCTR
00:0000E40B   BADSLCT
00:0000E40D   RODISK
00:0000E40F   ROFILE
00:0000E411   FBASE1
00:00000029   NFUNCTS
00:0000E447   FUNCTNS
00:0000E499   ERROR1
00:0000E4A5   ERROR2
00:0000E4AB   ERROR3
00:0000E4B1   ERROR4
00:0000E4B4   ERROR5
00:0000E4BA   BDOSERR
00:0000E4C6   BDOSDRV
00:0000E4CA   BADSEC
00:0000E4D5   BADSEL
00:0000E4DC   FILERO
00:0000E4E1   DISKRO
00:0000E4E5   PRTERR
00:0000E4FB   GETCHAR
00:0000E506   GETECHO
00:0000E514   CHKCHAR
00:0000E523   CKCONSOL
00:0000E542   CKCON1
00:0000E545   CKCON2
00:0000E548   OUTCHAR
00:0000E562   OUTCHR1
00:0000E579   OUTCHR2
00:0000E57F   SHOWIT
00:0000E590   OUTCON
00:0000E596   OUTCON1
00:0000E5A4   BACKUP
00:0000E5AC   BACKUP1
00:0000E5B1   NEWLINE
00:0000E5B9   NEWLN1
00:0000E5C9   OUTCRLF
00:0000E5D3   PRTMESG
00:0000E5E1   RDBUFF
00:0000E5EF   RDBUF1
00:0000E5F1   RDBUF2
00:0000E616   RDBUF3
00:0000E626   RDBUF4
00:0000E637   RDBUF5
00:0000E648   RDBUF6
00:0000E64E   RDBUF7
00:0000E65F   RDBUF8
00:0000E66B   RDBUF9
00:0000E670   RDBUF10
00:0000E678   RDBUF11
00:0000E68A   RDBUF12
00:0000E699   RDBUF13
00:0000E6A6   RDBUF14
00:0000E6A9   RDBUF15
00:0000E6BD   RDBUF16
00:0000E6C1   RDBUF17
00:0000E6C8   GETCON
00:0000E6CE   GETRDR
00:0000E6D4   DIRCIO
00:0000E6E0   DIRC1
00:0000E6ED   GETIOB
00:0000E6F3   SETIOB
00:0000E6F8   PRTSTR
00:0000E6FE   GETCSTS
00:0000E701   SETSTAT
00:0000E704   RTN
00:0000E705   IOERR1
00:0000E70A   OUTFLAG
00:0000E70B   STARTING
00:0000E70C   CURPOS
00:0000E70D   PRTFLAG
00:0000E70E   CHARBUF
00:0000E70F   USRSTACK
00:0000E741   STKAREA
00:0000E741   USERNO
00:0000E742   ACTIVE
00:0000E743   PARAMS
00:0000E745   STATUS
00:0000E747   SLCTERR
00:0000E74A   JUMPHL
00:0000E74F   DE2HL
00:0000E750   DE2HL1
00:0000E759   SELECT
00:0000E79D   SELECT1
00:0000E7A1   HOMEDRV
00:0000E7B2   DOREAD
00:0000E7B8   DOWRITE
00:0000E7BB   IORET
00:0000E7C3   TRKSEC
00:0000E7D1   TRKSEC1
00:0000E7E4   TRKSEC2
00:0000E7FA   TRKSEC3
00:0000E80F   TRKSEC4
00:0000E83E   GETBLOCK
00:0000E845   GETBLK1
00:0000E853   GETBLK2
00:0000E85C   GETBLK3
00:0000E85E   EXTBLK
00:0000E871   EXTBLK1
00:0000E877   COMBLK
00:0000E884   CHKBLK
00:0000E88A   LOGICAL
00:0000E890   LOGICL1
00:0000E8A6   SETEXT
00:0000E8AE   SETHLDE
00:0000E8BB   STRDATA
00:0000E8D2   SETNREC
00:0000E8DE   STNREC1
00:0000E8EA   SHIFTR
00:0000E8EB   SHIFTR1
00:0000E8F7   CHECKSUM
00:0000E8FD   CHKSUM1
00:0000E905   SHIFTL
00:0000E906   SHIFTL1
00:0000E90C   SETBIT
00:0000E91F   GETWPRT
00:0000E92D   WRTPRTD
00:0000E945   CHKROFL
00:0000E948   CKROF1
00:0000E955   CHKWPRT
00:0000E95F   FCB2HL
00:0000E965   ADDA2HL
00:0000E96A   GETS2
00:0000E973   CLEARS2
00:0000E979   SETS2B7
00:0000E980   MOREFLS
00:0000E98D   CHKNMBR
00:0000E996   SUBHL
00:0000E99D   SETDIR
00:0000E99F   CHECKDIR
00:0000E9C5   CHKDIR1
00:0000E9C7   DIRWRITE
00:0000E9D5   DIRREAD
00:0000E9DB   DEFDMA
00:0000E9E1   DIRDMA
00:0000E9E4   DIRDMA1
00:0000E9EA   MOVEDIR
00:0000E9F6   CKFILPOS
00:0000E9FF   STFILPOS
00:0000EA06   NXENTRY
00:0000EA1A   NXENT1
00:0000EA21   NXENT2
00:0000EA36   CKBITMAP
00:0000EA57   CKBMAP1
00:0000EA5D   STBITMAP
00:0000EA65   STBMAP1
00:0000EA6C   SETFILE
00:0000EA76   SETFL1
00:0000EA89   SETFL2
00:0000EA8F   SETFL3
00:0000EA9E   SETFL4
00:0000EAA4   BITMAP
00:0000EAB2   BITMAP1
00:0000EAD3   BITMAP2
00:0000EAF7   BITMAP3
00:0000EB02   STSTATUS
00:0000EB08   SAMEXT
00:0000EB19   FINDFST
00:0000EB2E   FINDNXT
00:0000EB4B   FNDNXT1
00:0000EB54   FNDNXT2
00:0000EB74   FNDNXT3
00:0000EB7D   FNDNXT4
00:0000EB84   FNDNXT5
00:0000EB95   FNDNXT6
00:0000EB9D   ERAFILE
00:0000EBA5   ERAFIL1
00:0000EBBF   FNDSPACE
00:0000EBC1   FNDSPA1
00:0000EBD2   FNDSPA2
00:0000EBED   FNDSPA3
00:0000EBF5   FNDSPA4
00:0000EBFE   FCBSET
00:0000EC02   UPDATE
00:0000EC11   UPDATE1
00:0000EC17   CHGNAMES
00:0000EC28   CHGNAM1
00:0000EC3C   SAVEATTR
00:0000EC41   SAVATR1
00:0000EC52   OPENIT
00:0000EC5B   OPENIT1
00:0000EC8C   OPENIT2
00:0000EC95   MOVEWORD
00:0000ECA3   CLOSEIT
00:0000ECCE   CLOSEIT1
00:0000ECDC   CLOSEIT2
00:0000ECE2   CLOSEIT3
00:0000ECE9   CLOSEIT4
00:0000ECFE   CLOSEIT5
00:0000ED18   CLOSEIT6
00:0000ED20   CLOSEIT7
00:0000ED25   GETEMPTY
00:0000ED47   GETMT1
00:0000ED5B   GETNEXT
00:0000ED84   GTNEXT1
00:0000ED8F   GTNEXT2
00:0000EDAD   GTNEXT3
00:0000EDB0   GTNEXT4
00:0000EDB7   GTNEXT5
00:0000EDBD   RDSEQ
00:0000EDC2   RDSEQ1
00:0000EDE7   RDSEQ2
00:0000EDFC   RDSEQ3
00:0000EDFF   WTSEQ
00:0000EE04   WTSEQ1
00:0000EE3C   WTSEQ2
00:0000EE49   WTSEQ3
00:0000EE65   WTSEQ4
00:0000EE6D   WTSEQ5
00:0000EE6F   WTSEQ6
00:0000EE8D   WTSEQ7
00:0000EE9B   WTSEQ8
00:0000EEBC   WTSEQ9
00:0000EED3   WTSEQ10
00:0000EEE0 X WTSEQ99
00:0000EEFF   WTSEQ11
00:0000EF01   WTSEQ12
00:0000EF04   POSITION
00:0000EF08   POSITN1
00:0000EF48   POSITN2
00:0000EF80   POSITN3
00:0000EF85   POSITN4
00:0000EF8C   POSITN5
00:0000EF94   READRAN
00:0000EF9D   WRITERAN
00:0000EFA6   COMPRAND
00:0000EFD3   RANSIZE
00:0000EFE5   RANSIZ1
00:0000F005   RANSIZ2
00:0000F00B   RANSIZ3
00:0000F00D   SETRAN
00:0000F020   LOGINDRV
00:0000F044   SETDSK
00:0000F050   AUTOSEL
00:0000F074   AUTOSL1
00:0000F07D   GETVER
00:0000F082   RSTDSK
00:0000F09B   OPENFIL
00:0000F0A4   CLOSEFIL
00:0000F0AA   GETFST
00:0000F0C1   GETFST1
00:0000F0C7   GETNXT
00:0000F0D6   DELFILE
00:0000F0DF   READSEQ
00:0000F0E5   WRTSEQ
00:0000F0EB   FCREATE
00:0000F0F4   RENFILE
00:0000F0FD   GETLOG
00:0000F103   GETCRNT
00:0000F109   PUTDMA
00:0000F110   GETALOC
00:0000F116   GETROV
00:0000F11C   SETATTR
00:0000F125   GETPARM
00:0000F128   GETPRM1
00:0000F12C   GETUSER
00:0000F13A   SETUSER
00:0000F140   RDRANDOM
00:0000F146   WTRANDOM
00:0000F14C   FILESIZE
00:0000F152   LOGOFF
00:0000F173   GOBACK
00:0000F190   GOBACK1
00:0000F19A   WTSPECL
00:0000F1AB   EMPTYFCB
00:0000F1AC   WRTPRT
00:0000F1AE   LOGIN
00:0000F1B0   USERDMA
00:0000F1B2   SCRATCH1
00:0000F1B4   SCRATCH2
00:0000F1B6   SCRATCH3
00:0000F1B8   DIRBUF
00:0000F1BA   DISKPB
00:0000F1BC   CHKVECT
00:0000F1BE   ALOCVECT
00:0000F1C0   SECTORS
00:0000F1C2   BLKSHFT
00:0000F1C3   BLKMASK
00:0000F1C4   EXTMASK
00:0000F1C5   DSKSIZE
00:0000F1C7   DIRSIZE
00:0000F1C9   ALLOC0
00:0000F1CB   ALLOC1
00:0000F1CD   OFFSET
00:0000F1CF   XLATE
00:0000F1D1   CLOSEFLG
00:0000F1D2   RDWRTFLG
00:0000F1D3   FNDSTAT
00:0000F1D4   MODE
00:0000F1D5   EPARAM
00:0000F1D6   RELBLOCK
00:0000F1D7   COUNTER
00:0000F1D8   SAVEFCB
00:0000F1DC   BIGDISK
00:0000F1DD   AUTO
00:0000F1DE   OLDDRV
00:0000F1DF   AUTOFLAG
00:0000F1E0   SAVNXT
00:0000F1E1   SAVEXT
00:0000F1E2   SAVNREC
00:0000F1E4   BLKNMBR
00:0000F1E6   LOGSECT
00:0000F1E8   FCBPOS
00:0000F1E9   FILEPOS
00:0000F1EB   CKSUMTBL
00:0000F1FF X BOOT
00:0000F202   WBOOT
00:0000F205   CONST
00:0000F208   CONIN
00:0000F20B   CONOUT
00:0000F20E   LIST
00:0000F211   PUNCH
00:0000F214   READER
00:0000F217   HOME
00:0000F21A   SELDSK
00:0000F21D   SETTRK
00:0000F220   SETSEC
00:0000F223   SETDMA
00:0000F226   READ
00:0000F229   WRITE
00:0000F22C X PRSTAT
00:0000F22F   SECTRN


 Output: CPM22.out
-------------------------------------------------

 Page: 00
  Org: 0000DC00  Size: *  Used: 00001632

   Address   Length Align   Label
   0000DC00    5682         CBASE
